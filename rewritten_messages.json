{
    "fatal": {
        "F0001": {
            "name": "fatal",
            "message": "Oh, how lovely! It seems that an error has taken place and has unfortunately hindered the analysis of a particular module. Such a shame, really, especially when it could not be located. How inconvenient!",
            "description": "Used when an error occurred preventing the analysis of a               module (unable to find it for instance)."
        },
        "F0002": {
            "name": "astroid-error",
            "message": "Oh, look at that! We seem to have encountered an unforeseen error while attempting to build the Astroid representation. How delightful! Of course, it's always accompanied by a traceback, because why wouldn't it be? Do us a favor and report these oh-so-special errors, won't you? Thanks ever so much!",
            "description": "Used when an unexpected error occurred while building the Astroid  representation. This is usually accompanied by a traceback. Please report such errors !"
        },
        "F0010": {
            "name": "parse-error",
            "message": "Oh, look at that, an exception occurred while building the Astroid representation... not that astroid couldn't have handled it or anything.",
            "description": "Used when an exception occurred while building the Astroid representation which could be handled by astroid."
        },
        "F0011": {
            "name": "config-parse-error",
            "message": "\"Oh, look who decided to have an exception in the pylint configuration file!\"",
            "description": "Used when an exception occurred while parsing a pylint configuration file."
        },
        "F0202": {
            "name": "method-check-failed",
            "message": "Well, it seems that Pylint is having a bit of a tough time trying to figure out if the methods' signatures are compatible. Oh, what a surprise! If you're scratching your head in confusion, do us a favor and be sure to report this kind of nonsense. Thanks!",
            "description": "Used when Pylint has been unable to check methods signature compatibility for an unexpected reason. Please report this kind if you don't make sense of it."
        }
    },
    "error": {
        "E0001": {
            "name": "syntax-error",
            "message": "Oh, look! Another syntax error for the module. How surprising!",
            "description": "Used when a syntax error is raised for a module."
        },
        "E0011": {
            "name": "unrecognized-inline-option",
            "message": "Oh, how delightful! A wild unknown inline option appeared! How utterly fascinating to encounter something so mysterious. Please do enlighten us, dear code, as to what this enigmatic entity might be.",
            "description": "Used when an unknown inline option is encountered."
        },
        "E0013": {
            "name": "bad-plugin-value",
            "message": "Oh, so you decided to use a bad value in 'load-plugins'. How interesting. Good job there.",
            "description": "Used when a bad value is used in 'load-plugins'."
        },
        "E0014": {
            "name": "bad-configuration-section",
            "message": "Oh, look what we have here! Seems like someone decided to include a setting in the top level of their toml configuration that definitely doesn't belong there. How interesting!",
            "description": "Used when we detect a setting in the top level of a toml configuration that shouldn't be there."
        },
        "E0015": {
            "name": "unrecognized-option",
            "message": "Oh, well look at this fancy unrecognized option we've got here! How delightful to be graced with something we clearly cannot comprehend.",
            "description": "Used when we detect an option that we do not recognize."
        },
        "E1700": {
            "name": "yield-inside-async-function",
            "message": "Oh, look what we have here! It seems like someone thought it would be a great idea to use a `yield` or `yield from` statement inside an async function. How original. Can't wait to deal with the consequences of that brilliant decision.",
            "description": "Used when an `yield` or `yield from` statement is found inside an async function."
        },
        "E1701": {
            "name": "not-async-context-manager",
            "message": "Oh, I see we thought it would be funny to use an async context manager with an object that clearly doesn't have a clue about the async context management protocol. How clever of us!",
            "description": "Used when an async context manager is used with an object that does not implement the async context management protocol."
        },
        "E0111": {
            "name": "bad-reversed-sequence",
            "message": "Oh, how delightful! It seems someone here decided to use the reversed() builtin with an argument that is not a sequence. Aren't they just full of surprises? It appears this argument does not implement __reversed__, nor __getitem__ and __len__. How wonderful!",
            "description": "Used when the first argument to reversed() builtin isn't a sequence (does not implement __reversed__, nor __getitem__ and __len__"
        },
        "E0119": {
            "name": "misplaced-format-function",
            "message": "Oh, look at that! The format function is missing on the str object. How silly of you to do something like print(\"value: {}\").format(123) instead of the correct way, which is print(\"value: {}\".format(123)). I guess that might not be what you intended to do, but hey, it happens to the best of us!",
            "description": "Emitted when format function is not called on str object. e.g doing print(\"value: {}\").format(123) instead of print(\"value: {}\".format(123)). This might not be what the user intended to do."
        },
        "E0100": {
            "name": "init-is-generator",
            "message": "Wow, someone thought it would be a great idea to turn the oh-so-special class method __init__ into a generator by throwing a yield in its body. How ingenious!",
            "description": "Used when the special class method __init__ is turned into a generator by a yield in its body."
        },
        "E0101": {
            "name": "return-in-init",
            "message": "Oh, look who thinks they're special! Using an explicit return value in the __init__ method, huh? How original!",
            "description": "Used when the special class method __init__ has an explicit return value."
        },
        "E0102": {
            "name": "function-redefined",
            "message": "Oh, look who decided to redefine a function \/ class \/ method!",
            "description": "Used when a function \/ class \/ method is redefined."
        },
        "E0103": {
            "name": "not-in-loop",
            "message": "Oh, how lovely! Looks like someone forgot that the break or continue keywords are meant to be used only inside a loop. But hey, who needs rules anyway, right?",
            "description": "Used when break or continue keywords are used outside a loop."
        },
        "E0104": {
            "name": "return-outside-function",
            "message": "Oh look, another \"return\" statement just casually hanging out outside a function or method. So useful and logical. It's not like it's supposed to be there or anything. Clearly someone just forgot where it actually belongs. Keep up the great work!",
            "description": "Used when a \"return\" statement is found outside a function or method."
        },
        "E0105": {
            "name": "yield-outside-function",
            "message": "Oh, look at this! We found a little \"yield\" statement just hanging out here all by itself, outside of a proper function or method. How utterly astounding! I guess we're just throwing all the rules out the window today, aren't we? Keep up the great work, genius.",
            "description": "Used when a \"yield\" statement is found outside a function or method."
        },
        "E0106": {
            "name": "return-arg-in-generator",
            "message": "Oh look, another \"return\" statement with an argument, how original! Just love it when it's found lurking outside of a generator function or method, especially when there are some \"yield\" statements around. Keep up the fantastic work!",
            "description": "Used when a \"return\" statement with an argument is found outside in a generator function or method (e.g. with some \"yield\" statements)."
        },
        "E0107": {
            "name": "nonexistent-operator",
            "message": "Oh look, trying to use the C-style pre-increment or pre-decrement operator -- and ++, like we're in some other language. Hate to break it to you, but that doesn't fly in Python. Better luck next time!",
            "description": "Used when you attempt to use the C-style pre-increment or pre-decrement operator -- and ++, which doesn't exist in Python."
        },
        "E0108": {
            "name": "duplicate-argument-name",
            "message": "Oh, I'm sorry, but it seems like someone didn't quite grasp the concept that duplicate argument names in function definitions are actually considered syntax errors. How unfortunate.",
            "description": "Duplicate argument names in function definitions are syntax errors."
        },
        "E0110": {
            "name": "abstract-class-instantiated",
            "message": "Oh, look who decided to go ahead and instantiate an abstract class with `abc.ABCMeta` as the metaclass, even though it has abstract methods. How interesting.",
            "description": "Used when an abstract class with `abc.ABCMeta` as metaclass has abstract methods and is instantiated."
        },
        "E0112": {
            "name": "too-many-star-expressions",
            "message": "Oh, great job! You managed to include not just one, but multiple starred expressions (`*x`) in your assignment. Simply amazing! But, unfortunately, this brilliant move of yours is actually a SyntaxError. Keep up the good work!",
            "description": "Emitted when there are more than one starred expressions (`*x`) in an assignment. This is a SyntaxError."
        },
        "E0113": {
            "name": "invalid-star-assignment-target",
            "message": "Oh, how clever of you to use a star expression as a starred assignment target! Clearly, you must have thought this through very carefully.",
            "description": "Emitted when a star expression is used as a starred assignment target."
        },
        "E0114": {
            "name": "star-needs-assignment-target",
            "message": "Oh, look who forgot to use a star expression in an assignment target. How careless!",
            "description": "Emitted when a star expression is not used in an assignment target."
        },
        "E0115": {
            "name": "nonlocal-and-global",
            "message": "Oh, look at this genius move! Declaring a name as both nonlocal and global. How cute.",
            "description": "Emitted when a name is both nonlocal and global."
        },
        "E0116": {
            "name": "continue-in-finally",
            "message": "Just to let you know, it seems like someone mistakenly used the `continue` keyword within a finally clause, which is actually a SyntaxError. But hey, who needs proper syntax anyway, right?",
            "description": "Emitted when the `continue` keyword is found inside a finally clause, which is a SyntaxError."
        },
        "E0117": {
            "name": "nonlocal-without-binding",
            "message": "Oh, look who couldn't be bothered to give a name to their nonlocal variable in the parent scopes. How nice.",
            "description": "Emitted when a nonlocal variable does not have an attached name somewhere in the parent scopes"
        },
        "E0118": {
            "name": "used-prior-global-declaration",
            "message": "Oh, how delightful! Look at you, using a name before it has even been globally declared. Now that's bound to end in some good old-fashioned error-inducing fun, especially since Python 3.6. Bravo!",
            "description": "Emitted when a name is used prior a global declaration, which results in an error since Python 3.6."
        },
        "E0301": {
            "name": "non-iterator-returned",
            "message": "Well isn't it just fantastic when an __iter__ method decides to return something that isn't even iterable? I mean, who needs a `__next__` method anyways? It's not like that's a fundamental requirement or anything.",
            "description": "Used when an __iter__ method returns something which is not an iterable (i.e. has no `__next__` method)"
        },
        "E0302": {
            "name": "unexpected-special-method-signature",
            "message": "Oh, congratulations! You've managed to define a special method with an invalid number of parameters. Who needs things to actually work, right? It's not like following the rules and having the correct number of parameters would be important or anything. Keep up the great work!",
            "description": "Emitted when a special method was defined with an invalid number of parameters. If it has too few or too many, it might not work at all."
        },
        "E0303": {
            "name": "invalid-length-returned",
            "message": "\"Wow, looks like someone forgot that a __len__ method should return a non-negative integer. Keep up the great work!\"",
            "description": "Used when a __len__ method returns something which is not a non-negative integer"
        },
        "E0304": {
            "name": "invalid-bool-returned",
            "message": "It's just so impressive how this __bool__ method decides to return something that clearly isn't a bool. Like, why follow the rules when you can just do whatever you want, right?",
            "description": "Used when a __bool__ method returns something which is not a bool"
        },
        "E0305": {
            "name": "invalid-index-returned",
            "message": "Seems like someone's __index__ method decided to return something that is clearly not an integer. Very impressive!",
            "description": "Used when an __index__ method returns something which is not an integer"
        },
        "E0306": {
            "name": "invalid-repr-returned",
            "message": "Oh, apparently we've got some creative genius over here! The __repr__ method just couldn't resist showing off by returning something that isn't even a string. Way to keep us on our toes!",
            "description": "Used when a __repr__ method returns something which is not a string"
        },
        "E0307": {
            "name": "invalid-str-returned",
            "message": "Oh, how interesting! It appears that the __str__ method has generously decided to return something that is not a string. How marvelous!",
            "description": "Used when a __str__ method returns something which is not a string"
        },
        "E0308": {
            "name": "invalid-bytes-returned",
            "message": "Well, look who decided to return something that's not bytes in their __bytes__ method. How creative.",
            "description": "Used when a __bytes__ method returns something which is not bytes"
        },
        "E0309": {
            "name": "invalid-hash-returned",
            "message": "Well, isn't it just fabulous when the oh-so-clever __hash__ method decides to return something other than an integer? Absolutely brilliant!",
            "description": "Used when a __hash__ method returns something which is not an integer"
        },
        "E0310": {
            "name": "invalid-length-hint-returned",
            "message": "Oh, look who decided to return something that's not a non-negative integer in their __length_hint__ method. How charming.",
            "description": "Used when a __length_hint__ method returns something which is not a non-negative integer"
        },
        "E0311": {
            "name": "invalid-format-returned",
            "message": "Oh, apparently someone decided it was a brilliant idea for the __format__ method to return something other than a string. Well, that's great. Just great.",
            "description": "Used when a __format__ method returns something which is not a string"
        },
        "E0312": {
            "name": "invalid-getnewargs-returned",
            "message": "Oh, how insightful! It seems that someone's __getnewargs__ method has returned something other than a tuple. How unexpected and utterly bewildering!",
            "description": "Used when a __getnewargs__ method returns something which is not a tuple"
        },
        "E0313": {
            "name": "invalid-getnewargs-ex-returned",
            "message": "Oh, how interesting! The __getnewargs_ex__ method has decided to return something that does not conform to the expected format of tuple(tuple, dict). Very clever, indeed.",
            "description": "Used when a __getnewargs_ex__ method returns something which is not of the form tuple(tuple, dict)"
        },
        "E0202": {
            "name": "method-hidden",
            "message": "Oh, how lovely! Seems like this class has decided to define a method that is conveniently hidden by an instance attribute from its ancestor class or possibly overridden by some client code. Such a brilliant move!",
            "description": "Used when a class defines a method which is hidden by an instance attribute from an ancestor class or set by some client code."
        },
        "E0203": {
            "name": "access-member-before-definition",
            "message": "Oh, how impressive! Looks like someone just couldn't resist accessing an instance member before it had the honor of being assigned. Bravo!",
            "description": "Used when an instance member is accessed before it's actually assigned."
        },
        "E0211": {
            "name": "no-method-argument",
            "message": "Oh, it seems that someone forgot to define an argument in a method that obviously requires the bound instance as the first argument. How silly of them.",
            "description": "Used when a method which should have the bound instance as first argument has no argument defined."
        },
        "E0213": {
            "name": "no-self-argument",
            "message": "Wow, congratulations on breaking one of the most basic conventions in coding! It's truly amazing how you managed to use a different attribute instead of \"self\" as the first argument in your method. But hey, who needs standards anyway? Keep up the great work of defying common conventions! Just a small reminder, in case you were wondering, this is actually an error. But hey, it's your code, so why bother following common practices?",
            "description": "Used when a method has an attribute different the \"self\" as first argument. This is considered as an error since this is a so common convention that you shouldn't break it!"
        },
        "E0236": {
            "name": "invalid-slots-object",
            "message": "Oh, it seems we have the privilege of handling an object in __slots__ that is completely invalid and not even a string. How interesting!",
            "description": "Used when an invalid (non-string) object occurs in __slots__."
        },
        "E0237": {
            "name": "assigning-non-slot",
            "message": "Oh, how original! You've decided to assign to an attribute that was not defined in the class slots. How refreshing!",
            "description": "Used when assigning to an attribute not defined in the class slots."
        },
        "E0238": {
            "name": "invalid-slots",
            "message": "Seems like someone didn't bother to read the rule book. Apparently, a class with an invalid __slots__ was found. Sigh. Just a friendly reminder, only a string, an iterable, or a sequence is permitted. But, hey, who am I to judge?",
            "description": "Used when an invalid __slots__ is found in class. Only a string, an iterable or a sequence is permitted."
        },
        "E0239": {
            "name": "inherit-non-class",
            "message": "Oh, how interesting! It appears that someone has decided to have their class inherit from something that isn't even a class. Quite the clever choice, wouldn't you say?",
            "description": "Used when a class inherits from something which is not a class."
        },
        "E0240": {
            "name": "inconsistent-mro",
            "message": "Oh, look who decided to have an inconsistent method resolution order in their class!",
            "description": "Used when a class has an inconsistent method resolution order."
        },
        "E0241": {
            "name": "duplicate-bases",
            "message": "Oh, look at you using duplicate base classes in your derived classes! So original. Just a little heads up, though: that's going to raise TypeErrors. But I'm sure you'll figure it out eventually. Good luck!",
            "description": "Duplicate use of base classes in derived classes raise TypeErrors."
        },
        "E0242": {
            "name": "class-variable-slots-conflict",
            "message": "Oh, looks like someone's little __slots__ value decided to cause some trouble, conflicting with one of our precious class variables, properties, or methods. How delightful.",
            "description": "Used when a value in __slots__ conflicts with a class variable, property or method."
        },
        "E0243": {
            "name": "invalid-class-object",
            "message": "Ah, it seems we have mistakenly assigned an invalid object to the __class__ property. I must kindly remind you that only a class is permitted in this case. Just thought I'd mention it so we can avoid such unintentional errors in the future.",
            "description": "Used when an invalid object is assigned to a __class__ property. Only a class is permitted."
        },
        "E0244": {
            "name": "invalid-enum-extension",
            "message": "Oh, how quaint! It seems someone here didn't get the memo about trying to extend an inherited Enum class. Such a bold move, but alas, it will only result in a TypeError at runtime. But hey, who am I to stop you from making that mistake? Go ahead, knock yourself out!",
            "description": "Used when a class tries to extend an inherited Enum class. Doing so will raise a TypeError at runtime."
        },
        "E3701": {
            "name": "invalid-field-call",
            "message": "Oh, look who thinks they know how to use dataclasses.field()! Just a friendly reminder that this specifier should ONLY be used as the value of an assignment within a dataclass or within the make_dataclass() function. But hey, don't worry, I'm sure you know best.",
            "description": "The dataclasses.field() specifier should only be used as the value of an assignment within a dataclass, or within the make_dataclass() function."
        },
        "E0401": {
            "name": "import-error",
            "message": "Oh, look at that! Pylint seems to be having a bit of trouble importing a module. How unfortunate for it!",
            "description": "Used when pylint has been unable to import a module."
        },
        "E0402": {
            "name": "relative-beyond-top-level",
            "message": "Oh, look who's trying to access too many levels in the current package with their *fancy* relative import! Maybe next time, try not to go overboard with your package exploration, unless you want to have a little chat with pylint. Just a suggestion, of course.",
            "description": "Used when a relative import tries to access too many levels in the current package."
        },
        "E0701": {
            "name": "bad-except-order",
            "message": "Oh, what a surprise! It seems like someone didn't bother to put the except clauses in the correct order. Just a tiny detail, really. But I suppose it's not important that some exceptions might slip through and not be caught by the oh-so-critical specific handler. You know, it's your code, do whatever you want. Who cares about best practices anyway?",
            "description": "Used when except clauses are not in the correct order (from the more specific to the more generic). If you don't fix the order, some exceptions may not be caught by the most specific handler."
        },
        "E0702": {
            "name": "raising-bad-type",
            "message": "Oh, how delightful! Just imagine, raising something that is neither a class nor an instance. I must say, a `TypeError` shall be raised in this extraordinary scenario. How peculiar!",
            "description": "Used when something which is neither a class nor an instance is raised (i.e. a `TypeError` will be raised)."
        },
        "E0704": {
            "name": "misplaced-bare-raise",
            "message": "Oh, isn't it just lovely when a bare raise is omitted within an except clause? Such a delightful error it generates, you see, because there are simply no active exceptions left to be reraised. Of course, there's a special little exception to this rule, where a bare raise within a finally clause might possibly function, granted that an exception is raised within the try block. But oh dear, it's still quite a questionable coding practice that we really should not depend upon, for it reeks of a nasty code smell.",
            "description": "Used when a bare raise is not used inside an except clause. This generates an error, since there are no active exceptions to be reraised. An exception to this rule is represented by a bare raise inside a finally clause, which might work, as long as an exception is raised inside the try block, but it is nevertheless a code smell that must not be relied upon."
        },
        "E0705": {
            "name": "bad-exception-cause",
            "message": "Oh, how lovely! Look at you using the syntax \"raise ... from ...\" like a pro. Just one little thing though, the exception cause you provided is not an exception, nor None. But hey, who needs exceptions that actually make sense anyway? Keep up the good work!",
            "description": "Used when using the syntax \"raise ... from ...\", where the exception cause is not an exception, nor None."
        },
        "E0710": {
            "name": "raising-non-exception",
            "message": "Congratulations, you just raised a new style class that apparently doesn't see the value in inheriting from BaseException. Well done.",
            "description": "Used when a new style class which doesn't inherit from BaseException is raised."
        },
        "E0711": {
            "name": "notimplemented-raised",
            "message": "Oh, how delightful! We have the special treat of NotImplemented being raised instead of the much more common NotImplementedError. Such a rare occurrence indeed. How thrilling!",
            "description": "Used when NotImplemented is raised instead of NotImplementedError"
        },
        "E0712": {
            "name": "catching-non-exception",
            "message": "Oh, lovely choice of using a class that doesn't inherit from Exception as an exception in an except clause. Truly groundbreaking.",
            "description": "Used when a class which doesn't inherit from Exception is used as an exception in an except clause."
        },
        "E1200": {
            "name": "logging-unsupported-format",
            "message": "Oh, well, it seems like someone decided to use an unsupported format character in their oh-so-special logging statement format string. How interesting!",
            "description": "Used when an unsupported format character is used in a logging statement format string."
        },
        "E1201": {
            "name": "logging-format-truncated",
            "message": "Oh, look who couldn't finish their logging statement format string properly. How surprising.",
            "description": "Used when a logging statement format string terminates before the end of a conversion specifier."
        },
        "E1205": {
            "name": "logging-too-many-args",
            "message": "Oh, looks like we're playing a game of \"who can provide too many arguments for a logging format string!\" Congrats, you win this round.",
            "description": "Used when a logging format string is given too many arguments."
        },
        "E1206": {
            "name": "logging-too-few-args",
            "message": "Oh, look at this! Seems like someone didn't bother providing enough arguments for their precious logging format string. How thoughtful of them!",
            "description": "Used when a logging format string is given too few arguments."
        },
        "E3102": {
            "name": "positional-only-arguments-expected",
            "message": "Oh, looks like someone thought they were being clever by passing positional-only arguments as keyword arguments. But guess what? That's not how it works. So go ahead and remove those useless keywords from the function call, if you dare.",
            "description": "Emitted when positional-only arguments have been passed as keyword arguments. Remove the keywords for the affected arguments in the function call."
        },
        "E4702": {
            "name": "modified-iterating-dict",
            "message": "Oh, look who decided to add or remove items from a dict being iterated through! How utterly brilliant! Of course, doing so would raise a RuntimeError, but who am I to expect you to know that? No worries, I'm just here to remind you of your mistake. You're welcome.",
            "description": "Emitted when items are added or removed to a dict being iterated through. Doing so raises a RuntimeError."
        },
        "E4703": {
            "name": "modified-iterating-set",
            "message": "Oh! Looks like someone decided to add or remove items from the set while it was being iterated through. How thoughtful! Just FYI, this little action of theirs has triggered a delightful RuntimeError. Kudos to them for being so proactive!",
            "description": "Emitted when items are added or removed to a set being iterated through. Doing so raises a RuntimeError."
        },
        "E1003": {
            "name": "bad-super-call",
            "message": "Oh, how fascinating that someone decided to use a different class as the first argument for the super builtin. Clearly, they must have their reasons, although I can't quite understand what they might be. But no worries, I'm sure it'll all work out just fine.",
            "description": "Used when another argument than the current class is given as first argument of the super builtin."
        },
        "E1507": {
            "name": "invalid-envvar-value",
            "message": "Oh, aren't we clever? It seems that someone didn't bother reading the documentation. Just a gentle reminder that the env manipulation functions are only capable of dealing with string type arguments. You might want to take a look at this incredibly convenient link: https:\/\/docs.python.org\/3\/library\/os.html#os.getenv. Enjoy!",
            "description": "Env manipulation functions support only string type arguments. See https:\/\/docs.python.org\/3\/library\/os.html#os.getenv."
        },
        "E1519": {
            "name": "singledispatch-method",
            "message": "It seems like someone can't follow basic guidelines: singledispatch is meant for functions, not for class or instance methods. If you have trouble grasping this concept, maybe consider using singledispatchmethod instead. Just a thought.",
            "description": "singledispatch should decorate functions and not class\/instance methods. Use singledispatchmethod for those cases."
        },
        "E1520": {
            "name": "singledispatchmethod-function",
            "message": "It's just a little reminder that singledispatchmethod should be used exclusively for class\/instance methods, not for those mundane functions. For those cases, you'll be doing yourself a favor by switching to singledispatch. Cheers!",
            "description": "singledispatchmethod should decorate class\/instance methods and not functions. Use singledispatch for those cases."
        },
        "E1300": {
            "name": "bad-format-character",
            "message": "Oh, congratulations! You've managed to use an unsupported format character in your format string. How innovative of you!",
            "description": "Used when an unsupported format character is used in a format string."
        },
        "E1301": {
            "name": "truncated-format-string",
            "message": "Oh, how lovely! Looks like someone decided to cut a format string short before completing a conversion specifier. How thoughtful of them!",
            "description": "Used when a format string terminates before the end of a conversion specifier."
        },
        "E1302": {
            "name": "mixed-format-string",
            "message": "Dear developer,\nIt appears that you have decided to use both named (e.g. '%(foo)d') and unnamed (e.g. '%d') conversion specifiers in your format string. Bravo! This is a fabulous choice. Additionally, I see you have incorporated the * symbol for the minimum field width and\/or precision in your named conversion specifier. How creative! Keep up the excellent work!",
            "description": "Used when a format string contains both named (e.g. '%(foo)d') and unnamed (e.g. '%d') conversion specifiers.  This is also used when a named conversion specifier contains * for the minimum field width and\/or precision."
        },
        "E1303": {
            "name": "format-needs-mapping",
            "message": "Oh, how nice of you to use a format string with named conversion specifiers even though the argument you provided is not a mapping. That's just brilliant.",
            "description": "Used when a format string that uses named conversion specifiers is used with an argument that is not a mapping."
        },
        "E1304": {
            "name": "missing-format-string-key",
            "message": "Oh, look who decided to use a format string with named conversion specifiers without bothering to check if the dictionary actually has all the keys required by said format string. How irresponsible of you!",
            "description": "Used when a format string that uses named conversion specifiers is used with a dictionary that doesn't contain all the keys required by the format string."
        },
        "E1305": {
            "name": "too-many-format-args",
            "message": "Oh, do tell, seems like someone got a bit carried away with their arguments for that format string with unnamed conversion specifiers. Too many, really? How fascinating!",
            "description": "Used when a format string that uses unnamed conversion specifiers is given too many arguments."
        },
        "E1306": {
            "name": "too-few-format-args",
            "message": "Oh, so we think we're too good to provide enough arguments for those unnamed conversion specifiers in our precious format string?",
            "description": "Used when a format string that uses unnamed conversion specifiers is given too few arguments"
        },
        "E1307": {
            "name": "bad-string-format-type",
            "message": "How convenient that the type required by the format string is apparently not suitable for the actual argument type. Such a delightful oversight!",
            "description": "Used when a type required by format string is not suitable for actual argument type"
        },
        "E1310": {
            "name": "bad-str-strip-call",
            "message": "Seems like someone got a little too carried away with duplicate characters in their argument for a str.{l,r,}strip call. Time to clean up the mess!",
            "description": "The argument to a str.{l,r,}strip call contains a duplicate character,"
        },
        "E1133": {
            "name": "not-an-iterable",
            "message": "Oh wow, would you look at that? It seems someone thought it would be a brilliant idea to use a non-iterable value instead of an iterable one in a place where an iterable is actually expected. How incredibly thoughtful of them.",
            "description": "Used when a non-iterable value is used in place where iterable is expected"
        },
        "E1134": {
            "name": "not-a-mapping",
            "message": "Oh, how interesting! It seems that a non-mapping value has been used in a context where a mapping is typically expected. Quite the unconventional choice, wouldn't you agree?",
            "description": "Used when a non-mapping value is used in place where mapping is expected"
        },
        "E1101": {
            "name": "no-member",
            "message": "Oh, so you thought this variable had a nonexistent member? That's cute.",
            "description": "Used when a variable is accessed for a nonexistent member."
        },
        "E1102": {
            "name": "not-callable",
            "message": "Oh, sorry for assuming that you knew what you were doing, but apparently you're trying to call something that can't be called. So, have fun with your non-callable object!",
            "description": "Used when an object being called has been inferred to a non callable object."
        },
        "E1111": {
            "name": "assignment-from-no-return",
            "message": "Oh, how delightful! An assignment has been done on a function call, but alas, the inferred function seems to have forgotten the art of returning objects.",
            "description": "Used when an assignment is done on a function call but the inferred function doesn't return anything."
        },
        "E1120": {
            "name": "no-value-for-parameter",
            "message": "Oh, what a surprise! Looks like someone forgot to provide all the necessary arguments in their function call. How impressive!",
            "description": "Used when a function call passes too few arguments."
        },
        "E1121": {
            "name": "too-many-function-args",
            "message": "Oh look, someone can't seem to count or follow simple instructions. Too many pointless positional arguments in a function call. How surprising!",
            "description": "Used when a function call passes too many positional arguments."
        },
        "E1123": {
            "name": "unexpected-keyword-arg",
            "message": "Oh, how lovely! It seems that someone has decided to pass a keyword argument that doesn't quite match any of the parameter names in the function. Such a wonderfully creative way to cause confusion. Bravo!",
            "description": "Used when a function call passes a keyword argument that doesn't correspond to one of the function's parameter names."
        },
        "E1124": {
            "name": "redundant-keyword-arg",
            "message": "Oh, how wonderful! It seems that someone thought it was a brilliant idea to assign multiple values to a poor little function parameter. You know, one value from a measly positional argument and another from a pretentious keyword argument. How creative! Absolutely splendid!",
            "description": "Used when a function call would result in assigning multiple values to a function parameter, one value from a positional argument and one from a keyword argument."
        },
        "E1125": {
            "name": "missing-kwoa",
            "message": "Oh look, someone forgot to include a mandatory keyword-only argument in their function call. How unexpected.",
            "description": "Used when a function call does not pass a mandatory keyword-only argument."
        },
        "E1126": {
            "name": "invalid-sequence-index",
            "message": "Apparently someone thought it was a brilliant idea to index a sequence type with an INVALID type. Just so you know, the only ACCEPTABLE types for indexing are ints, slices, and objects with an __index__ method. But, hey, feel free to keep defying logic and common sense.",
            "description": "Used when a sequence type is indexed with an invalid type. Valid types are ints, slices, and objects with an __index__ method."
        },
        "E1127": {
            "name": "invalid-slice-index",
            "message": "Well, well, well. Looks like someone got a little carried away with their slice index. Newsflash, it should be an integer, None, or an object with an __index__ method. But feel free to keep ignoring the rules if you really don't mind wasting your time. Just a friendly suggestion, you know?",
            "description": "Used when a slice index is not an integer, None, or an object with an __index__ method."
        },
        "E1128": {
            "name": "assignment-from-none",
            "message": "Well, it seems that someone has decided to assign a variable on a function call, even though the inferred function couldn't be bothered to return anything other than None. But hey, who needs a useful return value anyway, right? Just trying to keep things interesting, I guess.",
            "description": "Used when an assignment is done on a function call but the inferred function returns nothing but None."
        },
        "E1129": {
            "name": "not-context-manager",
            "message": "Oh, how delightful! It seems that someone forgot to implement the context manager protocol (__enter__\/__exit__) for this instance used in a with statement. How positively wonderful!",
            "description": "Used when an instance in a with statement doesn't implement the context manager protocol(__enter__\/__exit__)."
        },
        "E1130": {
            "name": "invalid-unary-operand-type",
            "message": "Well, well, well, seems like someone didn't bother checking if the object they were using could handle a unary operand. I guess they thought they were just *so* clever, trying to perform an operation that is clearly not supported. Nice work, really.",
            "description": "Emitted when a unary operand is used on an object which does not support this type of operation."
        },
        "E1131": {
            "name": "unsupported-binary-operation",
            "message": "Oh, look at that! Seems like someone tried to perform a binary arithmetic operation between two operands that are not supported. How interesting!",
            "description": "Emitted when a binary arithmetic operation between two operands is not supported."
        },
        "E1132": {
            "name": "repeated-keyword",
            "message": "Oh, look at that! We've got ourselves a situation here where someone just couldn't resist themselves and decided to pass multiple values for a keyword in a function call. Bravo! A round of applause for this amazing display of complete disregard for basic programming principles. Well done!",
            "description": "Emitted when a function call got multiple values for a keyword."
        },
        "E1135": {
            "name": "unsupported-membership-test",
            "message": "Oh great, looks like someone forgot to implement the membership protocol (__contains__\/__iter__\/__getitem__) in that instance used in the membership test expression. How wonderful.",
            "description": "Emitted when an instance in membership test expression doesn't implement membership protocol (__contains__\/__iter__\/__getitem__)."
        },
        "E1136": {
            "name": "unsubscriptable-object",
            "message": "Oh, how delightful! It appears that someone has attempted to access a subscripted value that simply cannot be subscripted. How unfortunate that this particular value has neglected to define the oh-so-essential __getitem__ method or __class_getitem__ for its class. Such oversight!",
            "description": "Emitted when a subscripted value doesn't support subscription (i.e. doesn't define __getitem__ method or __class_getitem__ for a class)."
        },
        "E1137": {
            "name": "unsupported-assignment-operation",
            "message": "Just a friendly reminder: certain objects seem to be incapable of handling item assignment. You know, those objects that forget to define the __setitem__ method. It's not a big deal, really. Just thought I'd point it out. Have a splendid day!",
            "description": "Emitted when an object does not support item assignment (i.e. doesn't define __setitem__ method)."
        },
        "E1138": {
            "name": "unsupported-delete-operation",
            "message": "Oh, look at you, thinking you're special! This object here has no clue how to delete items, I mean, who needs that anyway? Clearly didn't bother defining the __delitem__ method. How lazy can you get?",
            "description": "Emitted when an object does not support item deletion (i.e. doesn't define __delitem__ method)."
        },
        "E1139": {
            "name": "invalid-metaclass",
            "message": "Oh, congratulations on using something that might be invalid as a metaclass! We just love detecting when a class decides to go against the norm and use such questionable choices.",
            "description": "Emitted whenever we can detect that a class is using, as a metaclass, something which might be invalid for using as a metaclass."
        },
        "E1141": {
            "name": "dict-iter-missing-items",
            "message": "Just a helpful reminder that you might want to consider calling .items() if you ever feel like iterating through a dict. It's just a small suggestion that could make your life a little bit easier, but hey, it's totally up to you.",
            "description": "Emitted when trying to iterate through a dict without calling .items()"
        },
        "E1142": {
            "name": "await-outside-async",
            "message": "Well, it seems someone couldn't resist using await outside of an async function. Just a friendly reminder, that's not how it's supposed to work. Keep that in mind next time.",
            "description": "Emitted when await is used outside an async function."
        },
        "E1143": {
            "name": "unhashable-member",
            "message": "Oh, look who's trying to use a dict key or set member that's not hashable. Way to go genius, maybe try defining a __hash__ method next time before crying to me about it.",
            "description": "Emitted when a dict key or set member is not hashable (i.e. doesn't define __hash__ method)."
        },
        "E1144": {
            "name": "invalid-slice-step",
            "message": "Well, well, well. It seems someone forgot to implement a custom __getitem__ method. And not to mention, they also decided to use a slice step of 0. Bravo! Just brilliant.",
            "description": "Used when a slice step is 0 and the object doesn't implement a custom __getitem__ method."
        },
        "E6004": {
            "name": "broken-noreturn",
            "message": "Oh joy, looks like someone thought it would be funny to break ``typing.NoReturn`` inside compound types in Python 3.7.0 and 3.7.1. But fear not, there's a workaround! Unless you actually need runtime introspection (which I highly doubt), you can switch to using string annotation like a modern civilized programmer. Just slap a ``Callable[..., 'NoReturn']`` on there and call it a day. But if you really enjoy bug hunting, feel free to check out the lovely details at https:\/\/bugs.python.org\/issue34921. Enjoy!",
            "description": "``typing.NoReturn`` inside compound types is broken in Python 3.7.0 and 3.7.1. If not dependent on runtime introspection, use string annotation instead. E.g. ``Callable[..., 'NoReturn']``. https:\/\/bugs.python.org\/issue34921"
        },
        "E6005": {
            "name": "broken-collections-callable",
            "message": "Oh, by the way, just wanted to mention that the glorious `collections.abc.Callable` you've been using inside Optional and Union is completely broken in Python 3.9.0 and 3.9.1. No biggie, though! Instead, I recommend you switch to the oh-so-perfect `typing.Callable` for these cases. Trust me, it'll work like a charm! But hey, don't just take my word for it, feel free to check out the details and countless complaints about it on https:\/\/bugs.python.org\/issue42965. Have fun!",
            "description": "``collections.abc.Callable`` inside Optional and Union is broken in Python 3.9.0 and 3.9.1. Use ``typing.Callable`` for these cases instead. https:\/\/bugs.python.org\/issue42965"
        },
        "E2501": {
            "name": "invalid-unicode-codec",
            "message": "Oh, look at you using UTF-16\/UTF-32 like it's still the stone age. Just a little suggestion, maybe consider using UTF-8 for compatibility instead. But hey, who am I to tell you what to do? If you're interested, you can also check out this handy link, https:\/\/bugs.python.org\/issue1503789, for a fascinating history lesson on this issue. And if you're really up for it, you might want to take a gander at this link, https:\/\/softwareengineering.stackexchange.com\/questions\/102205\/, where people talk about all the problems you can run into when using UTF-16. But hey, it's your choice after all.",
            "description": "For compatibility use UTF-8 instead of UTF-16\/UTF-32. See also https:\/\/bugs.python.org\/issue1503789 for a history of this issue. And https:\/\/softwareengineering.stackexchange.com\/questions\/102205\/ for some possible problems when using UTF-16 for instance."
        },
        "E2502": {
            "name": "bidirectional-unicode",
            "message": "Oh, bidirectional unicode, how delightful! They're just the cherry on top when it comes to displaying right-to-left (RTL) scripts like Chinese, Japanese, Arabic, Hebrew, and the like, correctly. But seriously, can you actually trust this code? Are you absolutely sure it's going to display correctly in every single editor out there? Because, you know, if you didn't write it or if your language isn't RTL, you might as well remove those fancy special characters. Who knows what they could be hiding? They might be plotting to trick you into executing code that does something completely different from what it appears to do. How fun! But hey, if you're into taking risks, go right ahead. Just thought you should know. Oh, and in case you crave more information on the topic, here are some lovely links for you: \nhttps:\/\/en.wikipedia.org\/wiki\/Bidirectional_text\nhttps:\/\/trojansource.codes\/",
            "description": "bidirectional unicode are typically not displayed characters required to display right-to-left (RTL) script (i.e. Chinese, Japanese, Arabic, Hebrew, ...) correctly. So can you trust this code? Are you sure it displayed correctly in all editors? If you did not write it or your language is not RTL, remove the special characters, as they could be used to trick you into executing code, that does something else than what it looks like.\nMore Information:\nhttps:\/\/en.wikipedia.org\/wiki\/Bidirectional_text\nhttps:\/\/trojansource.codes\/"
        },
        "E2510": {
            "name": "invalid-character-backspace",
            "message": "Oh, how thoughtful of you to move the cursor back, just so the character after it can gleefully overwrite the character before. Such a selfless act.",
            "description": "Moves the cursor back, so the character after it will overwrite the character before."
        },
        "E2511": {
            "name": "invalid-character-carriage-return",
            "message": "Oh, so you thought it would be a great idea to move the cursor to the start of the line and just let subsequent characters overwrite everything? Brilliant move, simply brilliant.",
            "description": "Moves the cursor to the start of line, subsequent characters overwrite the start of the line."
        },
        "E2512": {
            "name": "invalid-character-sub",
            "message": "Oh, look who thinks they're so clever pressing Ctrl+Z \"End of text\" on Windows. Yeah, some programs (like type) totally don't care about anything else in the file afterward. But hey, you do you. Keep on pretending you're a tech wizard.",
            "description": "Ctrl+Z \"End of text\" on Windows. Some programs (such as type) ignore the rest of the file after it."
        },
        "E2513": {
            "name": "invalid-character-esc",
            "message": "Oh, aren't we just a master of initiating escape codes that give us complete control over the terminal? How impressive.",
            "description": "Commonly initiates escape codes which allow arbitrary control of the terminal."
        },
        "E2514": {
            "name": "invalid-character-nul",
            "message": "Oh wow, looks like someone forgot how to properly close their Python script. Must be nice to think the input just magically ends itself.",
            "description": "Mostly end of input for python."
        },
        "E2515": {
            "name": "invalid-character-zero-width-space",
            "message": "Oh, well isn't this just delightful? It appears that someone has taken the time to play a little game of hide-and-seek with their code execution. How positively charming! Just thought you should know that there seems to be an invisible space character lurking about, ready to cause some mischief. But hey, who needs code that's actually visible and easy to understand, right?",
            "description": "Invisible space character could hide real code execution."
        },
        "E0601": {
            "name": "used-before-assignment",
            "message": "Oh, look who decided to access a local variable before bothering to assign a value to it. Did you really think it would magically have a value without any effort on your part? Just so you know, those assignments in try blocks are conveniently ignored when evaluating except\/finally blocks, as if they never happened. And don't even get me started on those pathetic assignments in except blocks that are conveniently forgotten when evaluating statements outside the block, unless the try block has a return statement. But hey, why would anyone expect you to understand such basic concepts?",
            "description": "Emitted when a local variable is accessed before its assignment took place. Assignments in try blocks are assumed not to have occurred when evaluating associated except\/finally blocks. Assignments in except blocks are assumed not to have occurred when evaluating statements outside the block, except when the associated try block contains a return statement."
        },
        "E0602": {
            "name": "undefined-variable",
            "message": "Oh, how delightful! It appears that someone has attempted to access an undefined variable. How peculiar indeed!",
            "description": "Used when an undefined variable is accessed."
        },
        "E0603": {
            "name": "undefined-all-variable",
            "message": "Oh look, another genius move referencing an undefined variable name in __all__. Well done!",
            "description": "Used when an undefined variable name is referenced in __all__."
        },
        "E0604": {
            "name": "invalid-all-object",
            "message": "Oh, well look at that! Seems like someone went ahead and sneaked in an invalid (non-string) object into __all__. How thoughtful!",
            "description": "Used when an invalid (non-string) object occurs in __all__."
        },
        "E0605": {
            "name": "invalid-all-format",
            "message": "Oh, look! Seems like __all__ has an invalid format. How nice!",
            "description": "Used when __all__ has an invalid format."
        },
        "E0611": {
            "name": "no-name-in-module",
            "message": "Oh, look who can't find a name in a module!",
            "description": "Used when a name cannot be found in a module."
        },
        "E0633": {
            "name": "unpacking-non-sequence",
            "message": "Oh, well aren't you just a rule breaker? Trying to use something that clearly isn't a sequence in an unpack assignment. How original of you.",
            "description": "Used when something which is not a sequence is used in an unpack assignment"
        },
        "E0643": {
            "name": "potential-index-error",
            "message": "Oh, how impressive! Looks like someone decided to go beyond the boundaries of an iterable with their index. Quite the rebel, aren't we? Let's just emit this little message to remind them of their little mishap.",
            "description": "Emitted when an index used on an iterable goes beyond the length of that iterable."
        }
    },
    "warning": {
        "W0012": {
            "name": "unknown-option-value",
            "message": "Oh wow, looks like someone encountered an unknown value for an option. How interesting!",
            "description": "Used when an unknown value is encountered for an option."
        },
        "W3601": {
            "name": "bad-chained-comparison",
            "message": "Oh look, seems like someone got a little carried away with their comparisons here. Can't help but wonder if they really understand the meaning behind \"<\" and \"is\". It's quite amusing how they thought chaining them together in \"0 < x is None\" was a grand idea. Definitely a classic mistake, to say the least.",
            "description": "Used when there is a chained comparison where one expression is part of two comparisons that belong to different semantic groups (\"<\" does not mean the same thing as \"is\", chaining them in \"0 < x is None\" is probably a mistake)."
        },
        "W0143": {
            "name": "comparison-with-callable",
            "message": "Oh look, pylint has found yet another comparison with a callable. Maybe someone forgot to add those pesky parentheses, leading to some potential unwanted behavior. How interesting!",
            "description": "This message is emitted when pylint detects that a comparison with a callable was made, which might suggest that some parenthesis were omitted, resulting in potential unwanted behaviour."
        },
        "W0177": {
            "name": "nan-comparison",
            "message": "Oh, congratulations on using NaN values like numpy.NaN and float('nan') in your expression. How wonderfully original of you!",
            "description": "Used when an expression is compared to NaN values like numpy.NaN and float('nan')."
        },
        "W0107": {
            "name": "unnecessary-pass",
            "message": "Oh, look who decided to use a pointless \"pass\" statement that could have easily been avoided. Bravo.",
            "description": "Used when a \"pass\" statement that can be avoided is encountered."
        },
        "W0101": {
            "name": "unreachable",
            "message": "Oh, look at this fancy code hiding behind a \"return\" or \"raise\" statement! Like anyone will ever bother accessing it.",
            "description": "Used when there is some code behind a \"return\" or \"raise\" statement, which will never be accessed."
        },
        "W0102": {
            "name": "dangerous-default-value",
            "message": "Oh, look at this clever use of mutable values like lists or dictionaries as default arguments! How innovative! But just a friendly reminder, it's generally frowned upon. Just thought you might like to know. Cheers!",
            "description": "Used when a mutable value as list or dictionary is detected in a default value for an argument."
        },
        "W0104": {
            "name": "pointless-statement",
            "message": "Well, it's rather fascinating how this statement appears to lack any sort of impact, doesn't it?",
            "description": "Used when a statement doesn't have (or at least seems to) any effect."
        },
        "W0105": {
            "name": "pointless-string-statement",
            "message": "Oh, so now you're using strings as statements? That's cute. Just so you know, it has absolutely no effect. But hey, don't worry, I even made a special message just for this foolishness. Feel free to disable it if you're using those strings as documentation, pretending they have some actual value.",
            "description": "Used when a string is used as a statement (which of course has no effect). This is a particular case of W0104 with its own message so you can easily disable it if you're using those strings as documentation, instead of comments."
        },
        "W0106": {
            "name": "expression-not-assigned",
            "message": "Oh, so clever of you to assign something that isn't even a function call to nothing. I bet you had some brilliant alternative in mind, didn't you?",
            "description": "Used when an expression that is not a function call is assigned to nothing. Probably something else was intended."
        },
        "W0108": {
            "name": "unnecessary-lambda",
            "message": "Oh, I see you decided to use a lambda expression to make a function call on the same argument list. Just so you know, in almost every situation, you could have just replaced that lambda with the actual function being called. But hey, you do you!",
            "description": "Used when the body of a lambda expression is a function call on the same argument list as the lambda itself; such lambda expressions are in all but a few cases replaceable with the function being called in the body of the lambda."
        },
        "W0109": {
            "name": "duplicate-key",
            "message": "Oh, look, someone decided to bind the same key multiple times in their dictionary expression. How creative.",
            "description": "Used when a dictionary expression binds the same key multiple times."
        },
        "W0122": {
            "name": "exec-used",
            "message": "Oh, look who decided to use the 'exec' statement. How adorable. Just so you know, using this function for user input is like playing with fire. And don't even get me started on how much slower it is compared to actual code. But hey, you do you. Just remember, it wouldn't hurt to explore some alternatives and maybe think about restricting the functions available. Just a thought.",
            "description": "Raised when the 'exec' statement is used. It's dangerous to use this function for a user input, and it's also slower than actual code in general. This doesn't mean you should never use it, but you should consider alternatives first and restrict the functions available."
        },
        "W0123": {
            "name": "eval-used",
            "message": "Oh, you're using the \"eval\" function? How interesting! Have you ever considered using `ast.literal_eval` instead? It's a much safer option for evaluating strings containing Python expressions from untrusted sources. But hey, it's up to you to decide what's best for your code. Just thought I'd mention it...",
            "description": "Used when you use the \"eval\" function, to discourage its usage. Consider using `ast.literal_eval` for safely evaluating strings containing Python expressions from untrusted sources."
        },
        "W0124": {
            "name": "confusing-with-statement",
            "message": "Oh how delightful! Here we have a situation where the magnificent `with` statement sees fit to return multiple values, yet decides to play a little game by using name binding with `as` only for a portion of those values. How utterly captivating! One must truly appreciate the confusion that ensues, as it becomes rather perplexing to decipher whether the context manager is bestowing upon us a grand tuple or if the unnamed node is in fact another splendid context manager. Truly, a perplexing delight!",
            "description": "Emitted when a `with` statement component returns multiple values and uses name binding with `as` only for a part of those values, as in with ctx() as a, b. This can be misleading, since it's not clear if the context manager returns a tuple or if the node without a name binding is another context manager."
        },
        "W0125": {
            "name": "using-constant-test",
            "message": "Oh, how creative! Look at that conditional statement using a constant value for its test. I suppose the user must have meant to totally confuse everyone.",
            "description": "Emitted when a conditional statement (If or ternary if) uses a constant value for its test. This might not be what the user intended to do."
        },
        "W0126": {
            "name": "missing-parentheses-for-call-in-test",
            "message": "Oh, how lovely! Looks like someone forgot to include those pesky parentheses when calling a function within a conditional statement. Nice try, though! Keep practicing!",
            "description": "Emitted when a conditional statement (If or ternary if) seems to wrongly call a function due to missing parentheses"
        },
        "W0127": {
            "name": "self-assigning-variable",
            "message": "Oh, wonderful! It seems someone thought it would be a brilliant idea to assign a variable to itself. Can you believe it? Just when you thought you had seen it all, right? Well, here's a little message to inform you that we have detected this highly questionable action. Bravo!",
            "description": "Emitted when we detect that a variable is assigned to itself"
        },
        "W0128": {
            "name": "redeclared-assigned-name",
            "message": "Oh, clearly someone needs to show off their redeclaring skills by doing it in the same assignment. How impressive! But no worries, we're here to remind you that you've achieved the great feat of redeclaring a variable. Keep up the good work!",
            "description": "Emitted when we detect that a variable was redeclared in the same assignment."
        },
        "W0129": {
            "name": "assert-on-string-literal",
            "message": "Oh, how lovely! Imagine having a string literal as the first argument of an assert statement. Clearly, that will effortlessly guarantee the assert always passes. How convenient.",
            "description": "Used when an assert statement has a string literal as its first argument, which will cause the assert to always pass."
        },
        "W0130": {
            "name": "duplicate-value",
            "message": "Oh, how delightful! It appears that our dear set contains the same value not once, but two or more times! How charming!",
            "description": "This message is emitted when a set contains the same value two or more times."
        },
        "W0131": {
            "name": "named-expr-without-context",
            "message": "Oh look, here we have another so-called \"named expression\" prancing about, completely disregarding any sense of proper context for its regular assignment. How dare it try to do assignments outside if, for, while, or a comprehension? Absolutely audacious!",
            "description": "Emitted if named expression is used to do a regular assignment outside a context like if, for, while, or a comprehension."
        },
        "W0133": {
            "name": "pointless-exception-statement",
            "message": "Oh, look at this! An exception was created, but apparently, nobody bothered to assign it, raise it, or even return it for potential use elsewhere. How considerate of them!",
            "description": "Used when an exception is created without being assigned, raised or returned for subsequent use elsewhere."
        },
        "W0134": {
            "name": "return-in-finally",
            "message": "Oh, lovely. Look what we have here. A 'return' statement has managed to sneak its way into a 'finally' block. Just thought you should know that such misconduct will direfully overwrite the return value of your precious function. But hey, who am I to say? Feel free to continue down this treacherous path if you so desire.",
            "description": "Emitted when a 'return' statement is found in a 'finally' block. This will overwrite the return value of a function and should be avoided."
        },
        "W0150": {
            "name": "lost-exception",
            "message": "Oh, how convenient! It seems that someone has decided to tuck away all the pesky exceptions that could have been raised in the try clause within the finally clause of this try...finally block. They won't be re-raised, of course, which makes troubleshooting a delightful guessing game for the rest of us.",
            "description": "Used when a break or a return statement is found inside the finally clause of a try...finally block: the exceptions raised in the try clause will be silently swallowed instead of being re-raised."
        },
        "W0199": {
            "name": "assert-on-tuple",
            "message": "Well, isn't it just fascinating that whenever you decide to call assert on a tuple, it magically ends up being true if the tuple is not empty and false if it is. How utterly surprising!",
            "description": "A call of assert on a tuple will always evaluate to true if the tuple is not empty, and will always evaluate to false if it is."
        },
        "W0120": {
            "name": "useless-else-on-loop",
            "message": "It would be absolutely delightful if loops only had an else clause when they are capable of exiting early with a break statement. Otherwise, it would be much more pleasing if the statements under else were on the same scope as the loop itself. But hey, you do you. Whatever floats your boat.",
            "description": "Loops should only have an else clause if they can exit early with a break statement, otherwise the statements under else should be on the same scope as the loop itself."
        },
        "W0717": {
            "name": "too-many-try-statements",
            "message": "Oh, look at you with your fancy \"try\" clause, thinking you can just throw in as many statements as you please. But no, no, no, my dear friend, that won't do. It seems someone forgot to tell you that too many statements in a \"try\" clause are a big no-no. Tsk tsk.",
            "description": "Try clause contains too many statements."
        },
        "W0201": {
            "name": "attribute-defined-outside-init",
            "message": "Oh, I see you've decided to define an instance attribute outside of the __init__ method. How bold and unconventional of you! I mean, who needs to follow the standard and logical approach, right? Just do things your own way, why not?",
            "description": "Used when an instance attribute is defined outside the __init__ method."
        },
        "W0211": {
            "name": "bad-staticmethod-argument",
            "message": "Oh, look who thinks they're so clever using \"self\" or some other fancy value as the first argument in a static method. I bet they must feel really special. Well, newsflash, you're not following the valid-classmethod-first-arg or valid-metaclass-classmethod-first-arg options. So you might want to reconsider your choices there, bud. Just saying.",
            "description": "Used when a static method has \"self\" or a value specified in valid-classmethod-first-arg option or valid-metaclass-classmethod-first-arg option as first argument."
        },
        "W0212": {
            "name": "protected-access",
            "message": "Oh, how delightful! Look at how we're accessing a protected member outside its class or a descendant. How audacious of us!",
            "description": "Used when a protected member (i.e. class member with a name beginning with an underscore) is access outside the class or a descendant of the class where it's defined."
        },
        "W0213": {
            "name": "implicit-flag-alias",
            "message": "Oh, wonderful! Looks like someone didn't bother checking before declaring multiple integer values within an enum.IntFlag class that share a common bit position. How thoughtful!",
            "description": "Used when multiple integer values declared within an enum.IntFlag class share a common bit position."
        },
        "W0221": {
            "name": "arguments-differ",
            "message": "Oh, look who thinks they know better than the implemented interface or the overridden method! How impressive. Just so you know, your extra arguments with default values are totally being ignored. But hey, it's not like we need them or anything.",
            "description": "Used when a method has a different number of arguments than in the implemented interface or in an overridden method. Extra arguments with default values are ignored."
        },
        "W0222": {
            "name": "signature-differs",
            "message": "Oh, congratulations! You seem to have made the creative decision to use a method signature that is different from what was specified in the implemented interface or in the overridden method. How innovative of you!",
            "description": "Used when a method signature is different than in the implemented interface or in an overridden method."
        },
        "W0223": {
            "name": "abstract-method",
            "message": "Seems like someone forgot to override an abstract method in a concrete class. How typical.",
            "description": "Used when an abstract method (i.e. raise NotImplementedError) is not overridden in concrete class."
        },
        "W0231": {
            "name": "super-init-not-called",
            "message": "It seems that someone forgot to call the __init__ method of the ancestor class in their fancy derived class. How thoughtful of them.",
            "description": "Used when an ancestor class method has an __init__ method which is not called by a derived class."
        },
        "W0233": {
            "name": "non-parent-init-called",
            "message": "Oh, isn't it just delightful when someone decides to call an __init__ method on a class that has absolutely no business being a direct ancestor of the analyzed class? Absolutely thrilling.",
            "description": "Used when an __init__ method is called on a class which is not in the direct ancestors for the analysed class."
        },
        "W0236": {
            "name": "invalid-overridden-method",
            "message": "Oh, look! It seems someone has so cleverly overridden a method in a way that completely disregards its base class. How genius! Now, get ready for some delightful potential bugs that will surely make runtime such a thrilling experience!",
            "description": "Used when we detect that a method was overridden in a way that does not match its base class which could result in potential bugs at runtime."
        },
        "W0237": {
            "name": "arguments-renamed",
            "message": "Oh, look at you using a different name for the method parameter than what is specified in the implemented interface or overridden method. How creative of you!",
            "description": "Used when a method parameter has a different name than in the implemented interface or in an overridden method."
        },
        "W0238": {
            "name": "unused-private-member",
            "message": "Oh, look at that private member being defined but never used. How productive.",
            "description": "Emitted when a private member of a class is defined but not used."
        },
        "W0239": {
            "name": "overridden-final-method",
            "message": "Oh look, someone decided to override a method that was clearly decorated with typing.final. How dare they defy the sacred rules of code!",
            "description": "Used when a method decorated with typing.final has been overridden."
        },
        "W0240": {
            "name": "subclassed-final-class",
            "message": "Oh, look at that! Seems like someone decided to subclass a class that was cleverly decorated with typing.final. How innovative.",
            "description": "Used when a class decorated with typing.final has been subclassed."
        },
        "W0244": {
            "name": "redefined-slots-in-subclass",
            "message": "Oh, so we're just casually re-defining slots in subclasses now, are we?",
            "description": "Used when a slot is re-defined in a subclass."
        },
        "W0245": {
            "name": "super-without-brackets",
            "message": "Oh, how delightful! Another instance of a call to super without brackets. Clearly, this \"non-call\" approach is working wonders and achieving nothing as expected. So impressive, really.",
            "description": "Used when a call to super does not have brackets and thus is not an actual call and does not work as expected."
        },
        "W0246": {
            "name": "useless-parent-delegation",
            "message": "Congratulations on another set of \"really useful\" overridden methods, where you seemingly put all your effort into making them as pointless as possible. It's truly impressive how you managed to rely on the parent or super() delegation to do the exact same thing as another method from the MRO, just so you could waste everyone's time. Keep up the amazing work!",
            "description": "Used whenever we can detect that an overridden method is useless, relying on parent or super() delegation to do the same thing as another method from the MRO."
        },
        "W0160": {
            "name": "consider-ternary-expression",
            "message": "Oh, look at all these multiple assign statements spread across if\/else blocks. It would be absolutely delightful if someone were to take the time to rewrite them with just a single assignment and a fancy ternary expression. But you know, whatever. I mean, it's not like it makes the code cleaner and more efficient or anything. Just a little suggestion!",
            "description": "Multiple assign statements spread across if\/else blocks can be rewritten with a single assignment and ternary expression"
        },
        "W0141": {
            "name": "bad-builtin",
            "message": "Oh look, someone's using a disallowed builtin function (as if they didn't see the bad-function option). Aww, how cute! It's like they're living in the stone age, who uses map or filter anymore? Time to step up your game with the cleaner alternatives like list comprehension, my friend. Just a little tip for ya!",
            "description": "Used when a disallowed builtin function is used (see the bad-function option). Usual disallowed functions are the ones like map, or filter , where Python offers now some cleaner alternative like list comprehension."
        },
        "W3201": {
            "name": "bad-dunder-name",
            "message": "Oh, well, it seems like someone thought it would be fun to misspell or use an unconventional name for their so-called \"dunder\" method. Apparently, they didn't bother to check that it actually matches the predefined list of acceptable dunder names. How original.",
            "description": "Used when a dunder method is misspelled or defined with a name not within the predefined list of dunder names."
        },
        "W1641": {
            "name": "eq-without-hash",
            "message": "Oh, so you think you're too good for implementing __hash__ just because you already have __eq__? Well, guess what, objects that don't have __hash__ will just get stuck with a measly None as their default implementation. Enjoy your basic hashing, I guess.",
            "description": "Used when a class implements __eq__ but not __hash__. Objects get None as their default __hash__ implementation if they also implement __eq__."
        },
        "W0401": {
            "name": "wildcard-import",
            "message": "Oh, how delightful! Looks like we have a little \"from module import *\" situation going on here.",
            "description": "Used when `from module import *` is detected."
        },
        "W0404": {
            "name": "reimported",
            "message": "How delightful it is that this module has been imported not just once, but multiple times! Quite the efficient use of resources, I must say.",
            "description": "Used when a module is imported more than once."
        },
        "W0406": {
            "name": "import-self",
            "message": "Oh, how clever! This module seems to think highly of itself, importing none other than... itself. How delightfully redundant.",
            "description": "Used when a module is importing itself."
        },
        "W0407": {
            "name": "preferred-module",
            "message": "Oh, look at this fancy code importing a module that apparently has a \"preferred replacement\" module. I guess someone thinks they know better than everyone else. How cute.",
            "description": "Used when a module imported has a preferred replacement module."
        },
        "W0410": {
            "name": "misplaced-future",
            "message": "Oh, isn't it just lovely that Python 2.5 and later force us to include the __future__ import as the very first non-docstring statement in the module? Absolutely delightful.",
            "description": "Python 2.5 and greater require __future__ import to be the first non docstring statement in the module."
        },
        "W0416": {
            "name": "shadowed-import",
            "message": "Oh, how clever! You've decided to give your module the same name as another import and create unnecessary confusion. Very impressive indeed.",
            "description": "Used when a module is aliased with a name that shadows another import."
        },
        "W4901": {
            "name": "deprecated-module",
            "message": "Oh, how delightful! We have ourselves a module that has been marked as deprecated, yet it is still being imported. Isn't that just fantastic?",
            "description": "A module marked as deprecated is imported."
        },
        "W0702": {
            "name": "bare-except",
            "message": "Wow, using a bare \"except:\" clause is such a great idea! It totally doesn't make it more difficult to interrupt a program with \"Control-C\" and it definitely doesn't hide any other issues that may arise. If you really want to catch ALL exceptions that indicate program errors, go ahead and use \"except Exception:\" (just a reminder, bare except is totally the same as \"except BaseException:\"). But hey, what do I know? You go ahead and do whatever you want.",
            "description": "A bare ``except:`` clause will catch ``SystemExit`` and ``KeyboardInterrupt`` exceptions, making it harder to interrupt a program with ``Control-C``, and can disguise other problems. If you want to catch all exceptions that signal program errors, use ``except Exception:`` (bare except is equivalent to ``except BaseException:``)."
        },
        "W0705": {
            "name": "duplicate-except",
            "message": "Oh, how impressive! Another piece of beautiful code where an except statement catches a type that was already caught by a previous handler. Clearly, the redundancy was intentional, because who needs efficiency and clarity when you can have duplicated error handling? Bravo!",
            "description": "Used when an except catches a type that was already caught by a previous handler."
        },
        "W0706": {
            "name": "try-except-raise",
            "message": "Oh, how amusing! It seems like someone has decided to use the \"raise\" operator as the first or only operator in their except handler. How utterly useless! You see, this little move of theirs simply raises the exception right back, without any purpose. So, my dear, why don't they do us all a favor and remove that pointless \"raise\" operator or, better yet, the entire try-except-raise block?",
            "description": "Used when an except handler uses raise as its first or only operator. This is useless because it raises back the exception immediately. Remove the raise operator or the entire try-except-raise block!"
        },
        "W0707": {
            "name": "raise-missing-from",
            "message": "Oh, just in case you were wondering, Python's oh-so-clever exception chaining feature happens to display both the flashy traceback of the current exception and the oh-so-precious original exception. You know, so you can be entertained by all the lovely details. And here's a little bonus tidbit for you: if, by any chance, you happen to raise yet another exception right after capturing one (because, let's face it, who doesn't love a good exception party), then the second exception is probably just a delightful re-wrapped version of the first one. It's like a nice little present for your debugging pleasure. But wait, there's more! In case you were still feeling a tad unsatisfied with your traceback experience, fear not! Python graciously offers you the option to use the oh-so-sophisticated \"raise from\" syntax to create an even better, more intimate link between those two oh-so-fascinating tracebacks in your final error. Enjoy playing with your tracebacks, dear developer!",
            "description": "Python's exception chaining shows the traceback of the current exception, but also of the original exception. When you raise a new exception after another exception was caught it's likely that the second exception is a friendly re-wrapping of the first exception. In such cases `raise from` provides a better link between the two tracebacks in the final error."
        },
        "W0711": {
            "name": "binary-op-exception",
            "message": "Oh, I see we have a fancy exception-catching situation here. It seems someone thought it would be a brilliant idea to catch exceptions of the form \"except A or B:\". Well, if you really can't resist catching multiple exceptions, why not go ahead and rewrite it as \"except (A, B):\"? That would be just absolutely magical.",
            "description": "Used when the exception to catch is of the form \"except A or B:\".  If intending to catch multiple, rewrite as \"except (A, B):\""
        },
        "W0715": {
            "name": "raising-format-tuple",
            "message": "Oh, look at this fancy code! Passing multiple arguments to an exception constructor, with the first one being a string literal full of mysterious placeholders for formatting. How clever!",
            "description": "Used when passing multiple arguments to an exception constructor, the first of them a string literal containing what appears to be placeholders intended for formatting"
        },
        "W0716": {
            "name": "wrong-exception-operation",
            "message": "Oh, look at you using an operation against an exception that it's not even valid for. Bravo! This lovely shortcut is often encountered when people just can't resist making binary operations between exceptions in their oh-so-fancy except handlers.",
            "description": "Used when an operation is done against an exception, but the operation is not valid for the exception in question. Usually emitted when having binary operations between exceptions in except handlers."
        },
        "W0718": {
            "name": "broad-exception-caught",
            "message": "Just a friendly reminder, but if you insist on using a naked \"except Exception:\" clause, you might accidentally stumble upon some unexpected exceptions. And trust me, it's a real treat when these hidden bugs come back to haunt you or make the painstaking process of debugging even more enjoyable. Happy coding!",
            "description": "If you use a naked ``except Exception:`` clause, you might end up catching exceptions other than the ones you expect to catch. This can hide bugs or make it harder to debug programs when unrelated errors are hidden."
        },
        "W0719": {
            "name": "broad-exception-raised",
            "message": "Oh, sure, go ahead and raise those incredibly generic exceptions. That way, you'll have no choice but to catch them in the most generic way possible. I hope you enjoy using a naked `except Exception:` clause, because that's exactly what you're signing up for. But hey, be prepared to catch all sorts of unexpected exceptions while you're at it. Who needs to actually catch the specific ones you're expecting, right? Just watch as your bugs get conveniently hidden or your program becomes a nightmare to debug thanks to those unrelated errors that are now mysteriously buried. Good luck with that!",
            "description": "Raising exceptions that are too generic force you to catch exceptions generically too. It will force you to use a naked ``except Exception:`` clause. You might then end up catching exceptions other than the ones you expect to catch. This can hide bugs or make it harder to debug programs when unrelated errors are hidden."
        },
        "W0301": {
            "name": "unnecessary-semicolon",
            "message": "Oh, look who thinks they're writing in C instead of Python with their unnecessary semi-colon at the end of the statement \ud83d\ude09.",
            "description": "Used when a statement is ended by a semi-colon (\";\"), which isn't necessary (that's python, not C ;)."
        },
        "W0311": {
            "name": "bad-indentation",
            "message": "Oh, how fascinating! Look what we have here - an unexpected number of tabulations or spaces that have been found. Well, isn't that just delightful?",
            "description": "Used when an unexpected number of indentation's tabulations or spaces has been found."
        },
        "W1201": {
            "name": "logging-not-lazy",
            "message": "Oh, look at you using the old and outdated \"logging.<logging method>(format_string % (format_args...))\" call form for your logging statement. How cute. Maybe you should consider using a more modern and efficient type of string formatting instead. I mean, you can still use the % formatting, but why not let the logging function handle the interpolation for you by passing the parameters as arguments? Unless, of course, you've disabled logging-fstring-interpolation, in which case you can use fstring formatting. And hey, if logging-format-interpolation is disabled too, you can always resort to the good old str.format. Just some friendly suggestions, of course. Take it or leave it.",
            "description": "Used when a logging statement has a call form of \"logging.<logging method>(format_string % (format_args...))\". Use another type of string formatting instead. You can use % formatting but leave interpolation to the logging function by passing the parameters as arguments. If logging-fstring-interpolation is disabled then you can use fstring formatting. If logging-format-interpolation is disabled then you can use str.format."
        },
        "W1202": {
            "name": "logging-format-interpolation",
            "message": "Oh, look at you using that fancy \"logging.<logging method>(format_string.format(format_args...))\" call form. How original. But guess what? You could actually use a different type of string formatting. I mean, you could use the oh-so-classic % formatting, but only if you pass the parameters as arguments and let the logging function handle the interpolation. And hey, if logging-fstring-interpolation is disabled (not that it matters), you can use fstring formatting. Oh, and in case you didn't know, if logging-not-lazy is disabled (not that anyone cares), you can just use % formatting like a normal person. But hey, it's your code, do whatever you want. I'm just here to judge.",
            "description": "Used when a logging statement has a call form of \"logging.<logging method>(format_string.format(format_args...))\". Use another type of string formatting instead. You can use % formatting but leave interpolation to the logging function by passing the parameters as arguments. If logging-fstring-interpolation is disabled then you can use fstring formatting. If logging-not-lazy is disabled then you can use % formatting as normal."
        },
        "W1203": {
            "name": "logging-fstring-interpolation",
            "message": "Oh, how delightful! It seems that someone here has used a logging statement with a call form of \"logging.<logging method>(f\"...\")\". Such creativity! Might I suggest using another type of string formatting instead? Feel free to use % formatting, but remember to leave interpolation to the logging function by passing the parameters as arguments. Of course, if logging-format-interpolation is disabled, you can always use str.format. And if logging-not-lazy is disabled, well, you can simply use % formatting as you normally would. Just a little something to consider, my dear friend. Enjoy your coding adventures!",
            "description": "Used when a logging statement has a call form of \"logging.<logging method>(f\"...\")\".Use another type of string formatting instead. You can use % formatting but leave interpolation to the logging function by passing the parameters as arguments. If logging-format-interpolation is disabled then you can use str.format. If logging-not-lazy is disabled then you can use % formatting as normal."
        },
        "W3101": {
            "name": "missing-timeout",
            "message": "Oh, look who decided not to set a 'timeout' parameter for the method and just let the default value do all the work! Well, congratulations, now your program will happily hang indefinitely when using 'requests'. But hey, who needs efficiency and responsiveness anyway?",
            "description": "Used when a method needs a 'timeout' parameter in order to avoid waiting for a long time. If no timeout is specified explicitly the default value is used. For example for 'requests' the program will never time out (i.e. hang indefinitely)."
        },
        "W0511": {
            "name": "fixme",
            "message": "Oh look, we've stumbled upon a little warning note like FIXME or XXX. How quaint.",
            "description": "Used when a warning note as FIXME or XXX is detected."
        },
        "W4701": {
            "name": "modified-iterating-list",
            "message": "Oh, would you look at that! It seems like someone decided to add or remove items from a list while it was being iterated through. How delightful! However, I must inform you that such actions can cause some quite unexpected behavior. So, if you are interested in avoiding any surprises, might I suggest using a copy of the list instead? Just a friendly little tip for you.",
            "description": "Emitted when items are added or removed to a list being iterated through. Doing so can result in unexpected behaviour, that is why it is preferred to use a copy of the list."
        },
        "W3301": {
            "name": "nested-min-max",
            "message": "Oh, I see you enjoy unnecessarily complicating things. Instead of having a simple expression like ``min(1, 2, 3)``, you insist on using nested calls like ``min(1, min(2, 3))``. Well, just thought I'd let you know that you could simplify it if you wanted to. But hey, who am I to question your unique coding style, right?",
            "description": "Nested calls ``min(1, min(2, 3))`` can be rewritten as ``min(1, 2, 3)``."
        },
        "W2402": {
            "name": "non-ascii-file-name",
            "message": "Well, if you're still living in the dark ages of Python 3.5, you'll be thrilled to know that PEP 3131 permits using non-ascii identifiers. But wait, there's a catch! Non-ascii file names are still a big no-no. And guess what? Some editors or tools might not even bother supporting all those fancy UTF-8 files. So have fun dealing with that!",
            "description": "Under python 3.5, PEP 3131 allows non-ascii identifiers, but not non-ascii file names.Since Python 3.5, even though Python supports UTF-8 files, some editors or tools don't."
        },
        "W0714": {
            "name": "overlapping-except",
            "message": "Oh, how absolutely delightful it is to see that you have managed to create an enthralling array of overlapped or identical exceptions in your handler. Simply magnificent. I must say, it's quite impressive how you've embraced the concept of entropy in your code. Please do carry on with your splendid work.",
            "description": "Used when exceptions in handler overlap or are identical"
        },
        "W9005": {
            "name": "multiple-constructor-doc",
            "message": "It would be utterly delightful if someone went out of their way to remove those pesky parameter declarations littering the class or constructor. Just a humble suggestion, you know.",
            "description": "Please remove parameter declarations in the class or constructor."
        },
        "W9006": {
            "name": "missing-raises-doc",
            "message": "It would be oh-so-nice if you could take the time to document exceptions for ALL of the raised exception types. We wouldn't want to inconvenience anyone or anything...",
            "description": "Please document exceptions for all raised exception types."
        },
        "W9008": {
            "name": "redundant-returns-doc",
            "message": "It would be greatly appreciated if the return\/rtype documentation of this method were kindly removed. Thanks!",
            "description": "Please remove the return\/rtype documentation from this method."
        },
        "W9010": {
            "name": "redundant-yields-doc",
            "message": "It would be wildly helpful if someone had the decency to remove the utterly pointless yields documentation from this method. Just saying.",
            "description": "Please remove the yields documentation from this method."
        },
        "W9011": {
            "name": "missing-return-doc",
            "message": "It would be absolutely fantastic if someone took the time to include some documentation about what this method returns. I mean, why bother giving any information about what this thing actually does, right? Just leave us all in the dark, trying to figure out what this method actually returns. Brilliant!",
            "description": "Please add documentation about what this method returns."
        },
        "W9012": {
            "name": "missing-return-type-doc",
            "message": "Oh, it would just be lovely if someone could bother to document the type returned by this method. You know, in case anyone actually cares about things like clarity and maintainability. But hey, who needs that, right? Just something to consider...",
            "description": "Please document the type returned by this method."
        },
        "W9013": {
            "name": "missing-yield-doc",
            "message": "Oh, it would be just lovely if someone were to add some documentation about what this generator yields. Wouldn't that be nice?",
            "description": "Please add documentation about what this generator yields."
        },
        "W9014": {
            "name": "missing-yield-type-doc",
            "message": "Oh, it would be absolutely delightful if someone could take the time to document the type yielded by this method. It's just a tiny request, but, you know, I understand if it's too much to ask. After all, documentation is such an inconsequential thing, isn't it? But hey, if someone feels like being helpful, it wouldn't hurt. Just saying.",
            "description": "Please document the type yielded by this method."
        },
        "W9015": {
            "name": "missing-param-doc",
            "message": "It would be soooo helpful if someone actually bothered to add parameter declarations for ALL parameters... Just saying.",
            "description": "Please add parameter declarations for all parameters."
        },
        "W9016": {
            "name": "missing-type-doc",
            "message": "Oh, look who forgot to add parameter type declarations for all parameters. It would be a shame if someone were to... I don't know... maybe actually read the guidelines and follow them. Just a thought. But hey, no big deal if you don't want to bother, right?",
            "description": "Please add parameter type declarations for all parameters."
        },
        "W9017": {
            "name": "differing-param-doc",
            "message": "Oh, I suppose it wouldn't hurt to at least consider checking the parameter names in declarations, just in case. But, you know, it's totally up to you. No big deal or anything.",
            "description": "Please check parameter names in declarations."
        },
        "W9018": {
            "name": "differing-type-doc",
            "message": "It would be so lovely if you could take some time to review the parameter names in type declarations. But hey, no pressure! Just a small suggestion, you know?",
            "description": "Please check parameter names in type declarations."
        },
        "W9019": {
            "name": "useless-param-doc",
            "message": "Wouldn't it be great if someone actually bothered to remove the ignored parameter documentation? Just saying.",
            "description": "Please remove the ignored parameter documentation."
        },
        "W9020": {
            "name": "useless-type-doc",
            "message": "It would be really great if someone could bother removing the ignored parameter type documentation. But hey, it's totally up to you.",
            "description": "Please remove the ignored parameter type documentation."
        },
        "W9021": {
            "name": "missing-any-param-doc",
            "message": "Oh, it would be absolutely wonderful if someone would take the time to add some parameter and\/or type documentation. But, you know, only if you feel like it. No pressure.",
            "description": "Please add parameter and\/or type documentation."
        },
        "W2901": {
            "name": "redefined-loop-name",
            "message": "Oh, look! Someone just had to go and overwrite a loop variable in the loop body. How utterly fascinating!",
            "description": "Used when a loop variable is overwritten in the loop body."
        },
        "W1501": {
            "name": "bad-open-mode",
            "message": "Oh, look at this! Python just so happens to support a whole range of modes including r, w, a[, x]. And guess what? There are even more options like b, +, and U (but only if you choose r). If you're actually interested, you can find more information at this incredibly useful link: https:\/\/docs.python.org\/3\/library\/functions.html#open",
            "description": "Python supports: r, w, a[, x] modes with b, +, and U (only with r) options. See https:\/\/docs.python.org\/3\/library\/functions.html#open"
        },
        "W1502": {
            "name": "boolean-datetime",
            "message": "Oh, it seems like someone thought it would be a great idea to hide those oh-so-subtle bugs by using datetime.time in a boolean context when it matches midnight UTC. How clever! But don't worry, they finally fixed this genius move in Python 3.5. In case you're curious, you can check out the reference at https:\/\/bugs.python.org\/issue13936. You're welcome!",
            "description": "Using datetime.time in a boolean context can hide subtle bugs when the time they represent matches midnight UTC. This behaviour was fixed in Python 3.5. See https:\/\/bugs.python.org\/issue13936 for reference."
        },
        "W1503": {
            "name": "redundant-unittest-assert",
            "message": "Oh, so you thought it was a great idea to pass a constant as the first argument for assertTrue and assertFalse? Well, congratulations! That means the condition will be perpetually true, in case you're actually interested. But hey, don't you worry, because of your brilliant maneuver, I'll make sure to send out a nice little warning just for you.",
            "description": "The first argument of assertTrue and assertFalse is a condition. If a constant is passed as parameter, that condition will be always true. In this case a warning should be emitted."
        },
        "W1506": {
            "name": "bad-thread-instantiation",
            "message": "It seems that someone forgot to pass the target function when instantiating the threading.Thread class. Apparently, they thought the first parameter magically becomes the target function, when in reality it's the group parameter. Just a little FYI for next time, folks.",
            "description": "The warning is emitted when a threading.Thread class is instantiated without the target function being passed as a kwarg or as a second argument. By default, the first parameter is the group param, not the target param."
        },
        "W1507": {
            "name": "shallow-copy-environ",
            "message": "Oh, just a friendly reminder that os.environ is not actually a dict object, but a mere proxy object. So, in case you didn't know, a shallow copy can still have some magical effects on the original object. You might want to check out this fancy link, https:\/\/bugs.python.org\/issue15373, to know more. Cheers!",
            "description": "os.environ is not a dict object but proxy object, so shallow copy has still effects on original object. See https:\/\/bugs.python.org\/issue15373 for reference."
        },
        "W1508": {
            "name": "invalid-envvar-default",
            "message": "Just a friendly reminder that those little functions you've been using to manipulate the environment, they actually return None or str values. So, if you had the brilliant idea of supplying something different as a default, well, let me tell you, that might just cause a few teeny tiny bugs here and there. But hey, I'm not here to judge, just thought I'd drop this link right here for your reference. Happy bug hunting! *wink*",
            "description": "Env manipulation functions return None or str values. Supplying anything different as a default may cause bugs. See https:\/\/docs.python.org\/3\/library\/os.html#os.getenv."
        },
        "W1509": {
            "name": "subprocess-popen-preexec-fn",
            "message": "Oh, look who thinks they know better! Just a friendly reminder that the preexec_fn parameter is not exactly the safest thing to use when you have threads in your application. Just thought you might want to know that your precious child process could potentially deadlock before exec is even called. But hey, if you absolutely insist on using it, just keep it super simple and minimize the number of libraries you call into. You're welcome! Also, here's the link you might want to check out for more information: https:\/\/docs.python.org\/3\/library\/subprocess.html#popen-constructor",
            "description": "The preexec_fn parameter is not safe to use in the presence of threads in your application. The child process could deadlock before exec is called. If you must use it, keep it trivial! Minimize the number of libraries you call into. See https:\/\/docs.python.org\/3\/library\/subprocess.html#popen-constructor"
        },
        "W1510": {
            "name": "subprocess-run-check",
            "message": "Oh, by the way, just a friendly reminder: the esteemed \"check\" keyword is set to False by default. So, you know what that means, right? It means that the process launched by \"subprocess.run\" can exit with a non-zero exit code and fail oh-so-quietly. Not that I'm trying to imply anything here, but it might be in your best interest to set it explicitly and make it ever so clear what the error-handling behavior is. Just a thought, you know.",
            "description": "The ``check`` keyword  is set to False by default. It means the process launched by ``subprocess.run`` can exit with a non-zero exit code and fail silently. It's better to set it explicitly to make clear what the error-handling behavior is."
        },
        "W1514": {
            "name": "unspecified-encoding",
            "message": "It would be sooo helpful if an encoding is specified when opening documents. Just FYI, relying on the system default implicitly can cause MAJOR issues on other operating systems. Like, seriously, check out https:\/\/peps.python.org\/pep-0597\/ for more info.",
            "description": "It is better to specify an encoding when opening documents. Using the system default implicitly can create problems on other operating systems. See https:\/\/peps.python.org\/pep-0597\/"
        },
        "W1515": {
            "name": "forgotten-debug-statement",
            "message": "It would be absolutely amazing if someone could maybe consider removing calls to breakpoint(), sys.breakpointhook(), and pdb.set_trace() from code that, you know, is not actively being debugged. Just a teeny-tiny suggestion, though. Thanks for, uh, considering it.",
            "description": "Calls to breakpoint(), sys.breakpointhook() and pdb.set_trace() should be removed from code that is not actively being debugged."
        },
        "W1518": {
            "name": "method-cache-max-size-none",
            "message": "Oh, so I see you've decorated a method with lru_cache or cache. Well, guess what? By doing that, you've effectively linked the 'self' argument to the function, meaning it will never be garbage collected. Unless, of course, you think your precious little instance will never need to be garbage collected (must be some fancy singleton). But, in case you actually care about proper memory management, it's highly recommended that you refactor your code to ditch this pattern or at least have the decency to add a maxsize to the cache. Oh, and just so you know, the default value for maxsize is a whopping 128. Happy coding!",
            "description": "By decorating a method with lru_cache or cache the 'self' argument will be linked to the function and therefore never garbage collected. Unless your instance will never need to be garbage collected (singleton) it is recommended to refactor code to avoid this pattern or add a maxsize to the cache. The default value for maxsize is 128."
        },
        "W4902": {
            "name": "deprecated-method",
            "message": "I guess someone thinks it's cute to mark this method as \"deprecated\" and threaten to remove it in the future.",
            "description": "The method is marked as deprecated and will be removed in the future."
        },
        "W4903": {
            "name": "deprecated-argument",
            "message": "Oh, I see you still insist on using the deprecated argument even though it will be removed in the future.",
            "description": "The argument is marked as deprecated and will be removed in the future."
        },
        "W4904": {
            "name": "deprecated-class",
            "message": "Just a friendly little heads up, this class you're using here is marked as deprecated. You know what that means, right? Oh, you don't? Well, it means that it's going to be removed in the future. So, maybe you might want to consider finding an alternative before it's too late. But hey, no pressure!",
            "description": "The class is marked as deprecated and will be removed in the future."
        },
        "W4905": {
            "name": "deprecated-decorator",
            "message": "Well, congratulations! You've managed to use a decorator that is marked as completely deprecated and will be removed from existence in the near future. Keep up the amazing work!",
            "description": "The decorator is marked as deprecated and will be removed in the future."
        },
        "W1401": {
            "name": "anomalous-backslash-in-string",
            "message": "Oh, look at you! Using a backslash in a literal string without even bothering to make it an escape. How... interesting.",
            "description": "Used when a backslash is in a literal string but not as an escape."
        },
        "W1402": {
            "name": "anomalous-unicode-escape-in-string",
            "message": "Oh, look who decided to use an escape like \\u in a byte string where it clearly has absolutely no effect. How clever.",
            "description": "Used when an escape like \\u is encountered in a byte string where it has no effect."
        },
        "W1404": {
            "name": "implicit-str-concat",
            "message": "Oh, look at that! The kind-hearted developer forgot to add a pesky little comma in the literal iterable definition. You know, because string literals are just miraculously supposed to concatenate themselves. But hey, who needs proper syntax anyway, right?",
            "description": "String literals are implicitly concatenated in a literal iterable definition : maybe a comma is missing ?"
        },
        "W1405": {
            "name": "inconsistent-quotes",
            "message": "It's absolutely adorable how quote delimiters are used inconsistently throughout this module. Well, unless of course you're just trying to avoid the unnecessary burden of escaping characters. But who needs consistency anyway, am I right?",
            "description": "Quote delimiters are not used consistently throughout a module (with allowances made for avoiding unnecessary escaping)."
        },
        "W1406": {
            "name": "redundant-u-string-prefix",
            "message": "Oh, how lovely! We have detected a string with the obsolete u prefix. You see, in the ancient times of Python 2, people had to use these prefixes to say their string was Unicode. It's just too bad that they didn't get the memo that Python 3.0 strings are already Unicode by default. But hey, who needs to keep up with the times, right?",
            "description": "Used when we detect a string with a u prefix. These prefixes were necessary in Python 2 to indicate a string was Unicode, but since Python 3.0 strings are Unicode by default."
        },
        "W1300": {
            "name": "bad-format-string-key",
            "message": "Oh, how lovely! It seems that we've stumbled upon a little issue here. It appears that someone has used a format string that includes named conversion specifiers, but made the unfortunate mistake of using a dictionary with keys that aren't all strings. Quite the oversight, wouldn't you say?",
            "description": "Used when a format string that uses named conversion specifiers is used with a dictionary whose keys are not all strings."
        },
        "W1301": {
            "name": "unused-format-string-key",
            "message": "Oh, I see we have a format string that just can't handle all the unnecessary keys in the dictionary. How unfortunate.",
            "description": "Used when a format string that uses named conversion specifiers is used with a dictionary that contains keys not required by the format string."
        },
        "W1302": {
            "name": "bad-format-string",
            "message": "Oh, so I see we have an invalid PEP 3101 format string here. How interesting!",
            "description": "Used when a PEP 3101 format string is invalid."
        },
        "W1303": {
            "name": "missing-format-argument-key",
            "message": "Oh, looks like we have a PEP 3101 format string here that is missing one or more of its precious required keywords! How careless!",
            "description": "Used when a PEP 3101 format string that uses named fields doesn't receive one or more required keywords."
        },
        "W1304": {
            "name": "unused-format-string-argument",
            "message": "Well, congratulations! Another instance of someone using a PEP 3101 format string with a named field, even though the argument isn't even required by the format string. Excellent job on complicating things unnecessarily!",
            "description": "Used when a PEP 3101 format string that uses named fields is used with an argument that is not required by the format string."
        },
        "W1305": {
            "name": "format-combined-specification",
            "message": "Oh, how clever! Mixing automatic field numbering (so unpredictable!) with manual field specification (just to confuse everyone!) in a PEP 3101 format string. How absolutely brilliant!",
            "description": "Used when a PEP 3101 format string contains both automatic field numbering (e.g. '{}') and manual field specification (e.g. '{0}')."
        },
        "W1306": {
            "name": "missing-format-attribute",
            "message": "Oh, how lovely! It seems someone thought it would be simply fantastic to use an attribute specifier ({0.length}) in their PEP 3101 format string. Unfortunately, the argument provided for formatting falls short in possessing said attribute. How marvelous!",
            "description": "Used when a PEP 3101 format string uses an attribute specifier ({0.length}), but the argument passed for formatting doesn't have that attribute."
        },
        "W1307": {
            "name": "invalid-format-index",
            "message": "Oh, so the PEP 3101 format string decides to use a lookup specifier ({a[1]}) huh? Well, guess what? The argument provided for formatting doesn't even bother to include or have that key as an attribute. Great job!",
            "description": "Used when a PEP 3101 format string uses a lookup specifier ({a[1]}), but the argument passed for formatting doesn't contain or doesn't have that key as an attribute."
        },
        "W1308": {
            "name": "duplicate-string-formatting-argument",
            "message": "Oh, look, another case of someone repeating arguments instead of using named string arguments. How original. Guess some people just can't be bothered to follow best practices. But hey, I guess it's too much to ask for a little efficiency and clarity in code.",
            "description": "Used when we detect that a string formatting is repeating an argument instead of using named string arguments"
        },
        "W1309": {
            "name": "f-string-without-interpolation",
            "message": "Oh, look at this fancy f-string without any interpolation variables. Is it just a normal string or are we dealing with a bug in the code? I guess we'll never know...",
            "description": "Used when we detect an f-string that does not use any interpolation variables, in which case it can be either a normal string or a bug in the code."
        },
        "W1310": {
            "name": "format-string-without-interpolation",
            "message": "Oh, how fascinating! We've stumbled upon a string that lacks any interpolation variables. It could be one of two things: a simple, unformatted string or perhaps, just maybe, a delightful bug in the code. Isn't that just riveting?",
            "description": "Used when we detect a string that does not have any interpolation variables, in which case it can be either a normal string without formatting or a bug in the code."
        },
        "W2101": {
            "name": "useless-with-lock",
            "message": "Oh, how interesting! It seems someone has gone through the trouble of creating a brand new lock instance using the \"with\" statement, even though it serves absolutely no purpose whatsoever. How thoughtful! Instead of wasting everyone's time like this, perhaps they could have had the courtesy to use an existing instance to acquire the lock. But hey, who needs efficiency when we can just create unnecessary instances, right?",
            "description": "Used when a new lock instance is created by using with statement which has no effect. Instead, an existing instance should be used to acquire lock."
        },
        "W1113": {
            "name": "keyword-arg-before-vararg",
            "message": "Oh, look who thinks they're so clever! If you dare to define a keyword argument before variable positional arguments, you might just find yourself with the oh-so-annoying dilemma of having multiple values passed for that parameter. All because you thought you were smart enough to call the method with keyword arguments. Good luck dealing with that mess!",
            "description": "When defining a keyword argument before variable positional arguments, one can end up in having multiple values passed for the aforementioned parameter in case the method is called with keyword arguments."
        },
        "W1114": {
            "name": "arguments-out-of-order",
            "message": "Oh, how delightful! The caller's argument names perfectly match the parameter names in the function signature, but, alas, they've chosen to ruin it all by not putting them in the correct order. Lovely!",
            "description": "Emitted  when the caller's argument names fully match the parameter names in the function signature but do not have the same order."
        },
        "W1115": {
            "name": "non-str-assignment-to-dunder-name",
            "message": "Oh, look who decided to assign a non-string value to __name__. How interesting.",
            "description": "Emitted when a non-string value is assigned to __name__"
        },
        "W1116": {
            "name": "isinstance-second-argument-not-valid-type",
            "message": "Oh, look who doesn't know how to use isinstance properly. The second argument is supposed to be a type, not whatever nonsense you're passing in. Maybe try reading the documentation next time? Just a thought.",
            "description": "Emitted when the second argument of an isinstance call is not a type."
        },
        "W1117": {
            "name": "kwarg-superseded-by-positional-arg",
            "message": "Oh, look who's trying to be clever with their function calls! A keyword argument that just happens to have the same name as a positional-only parameter? Bravo! And don't even get me started on the fact that this function also has a keyword variadic parameter dict. Clearly, someone's trying to show off here.",
            "description": "Emitted when a function is called with a keyword argument that has the same name as a positional-only parameter and the function contains a keyword variadic parameter dict."
        },
        "W6001": {
            "name": "deprecated-typing-alias",
            "message": "Oh, look who's still using deprecated typing aliases. How quaint.",
            "description": "Emitted when a deprecated typing alias is used."
        },
        "W2301": {
            "name": "unnecessary-ellipsis",
            "message": "Oh, how impressive, another ellipsis constant! How delightful! Just in case you didn't know, a line of code with an ellipsis is completely unnecessary if, and only if, there happens to be a pesky little docstring on the preceding line or, heaven forbid, a statement within the same scope. But hey, who needs efficiency and clean code anyway?",
            "description": "Used when the ellipsis constant is encountered and can be avoided. A line of code consisting of an ellipsis is unnecessary if there is a docstring on the preceding line or if there is a statement in the same scope."
        },
        "W2601": {
            "name": "using-f-string-in-unsupported-version",
            "message": "Oh, look what we have here! The precious user has set a py-version lower than 3.6, and now pylint is encountering an f-string. How delightful!",
            "description": "Used when the py-version set by the user is lower than 3.6 and pylint encounters an f-string."
        },
        "W2602": {
            "name": "using-final-decorator-in-unsupported-version",
            "message": "Oh, how delightful! It seems that the user has set a py-version lower than 3.8, and now we have encountered a \"typing.final\" decorator. How utterly fascinating!",
            "description": "Used when the py-version set by the user is lower than 3.8 and pylint encounters a ``typing.final`` decorator."
        },
        "W0601": {
            "name": "global-variable-undefined",
            "message": "\"Seems like someone decided to define a variable using the 'global' statement, yet conveniently forgot to actually define it in the module scope. Oh well, not my problem!\"",
            "description": "Used when a variable is defined through the \"global\" statement but the variable is not defined in the module scope."
        },
        "W0602": {
            "name": "global-variable-not-assigned",
            "message": "Well, it seems that if you happen to modify a variable defined in the global scope within an inner scope, the oh-so-important 'global' keyword is only required in that inner scope if there happens to be some assignment operation going on in there. Just a little something to keep in mind if you care about such trivialities.",
            "description": "When a variable defined in the global scope is modified in an inner scope, the 'global' keyword is required in the inner scope only if there is an assignment operation done in the inner scope."
        },
        "W0603": {
            "name": "global-statement",
            "message": "Oh, well look at you using the \"global\" statement to update a global variable. Pylint just loves discouraging that kind of thing. But hey, who says you can't go against the grain and still use it anyway?",
            "description": "Used when you use the \"global\" statement to update a global variable. Pylint discourages its usage. That doesn't mean you cannot use it!"
        },
        "W0604": {
            "name": "global-at-module-level",
            "message": "Oh, look who wants to play with the \"global\" statement at the module level, thinking it actually does something. How adorable.",
            "description": "Used when you use the \"global\" statement at the module level since it has no effect."
        },
        "W0611": {
            "name": "unused-import",
            "message": "Oh, look who decided to import a module or variable and then completely ignore it. Very impressive.",
            "description": "Used when an imported module or variable is not used."
        },
        "W0612": {
            "name": "unused-variable",
            "message": "\"Oh, I see we've joyfully defined a variable that won't be receiving any attention. How delightful!\"",
            "description": "Used when a variable is defined but not used."
        },
        "W0613": {
            "name": "unused-argument",
            "message": "Oh, congratulations on writing code that includes a completely useless function or method argument. I mean, who needs all those pesky variables anyway, right? Good job, genius.",
            "description": "Used when a function or method argument is not used."
        },
        "W0614": {
            "name": "unused-wildcard-import",
            "message": "Oh, well, apparently we're just importing a whole bunch of stuff we don't actually need. That's cool, no problem at all.",
            "description": "Used when an imported module or variable is not used from a `'from X import *'` style import."
        },
        "W0621": {
            "name": "redefined-outer-name",
            "message": "Oh, how clever! Your variable's name is so sneaky that it actually hides a name that was defined in an outer scope or except handler. Impressive.",
            "description": "Used when a variable's name hides a name defined in an outer scope or except handler."
        },
        "W0622": {
            "name": "redefined-builtin",
            "message": "Oh, how clever! Looks like someone thought they were being really creative by using a variable or function name that just happens to override a built-in. Good job, genius!",
            "description": "Used when a variable or function override a built-in."
        },
        "W0631": {
            "name": "undefined-loop-variable",
            "message": "Oh, how charming! Looks like someone forgot that a loop variable should only be used within the loop it belongs to. How terribly inconvenient!",
            "description": "Used when a loop variable (i.e. defined by a for loop or a list comprehension or a generator expression) is used outside the loop."
        },
        "W0632": {
            "name": "unbalanced-tuple-unpacking",
            "message": "Oh, congratulations on your unbalanced tuple unpacking in assignment! Absolutely love how you effortlessly managed to mess up something so simple. Keep up the good work!",
            "description": "Used when there is an unbalanced tuple unpacking in assignment"
        },
        "W0640": {
            "name": "cell-var-from-loop",
            "message": "Oh, how fascinating! It seems that someone has gone ahead and defined a variable inside a loop, which shall inevitably lead to all closures using the exact same value for this particular variable. Bravo, well done!",
            "description": "A variable used in a closure is defined in a loop. This will result in all closures using the same value for the closed-over variable."
        },
        "W0641": {
            "name": "possibly-unused-variable",
            "message": "Oh, look at this variable that might not even be used! How intriguing. I suppose it's because someone might be clever enough to use locals() and decide to either consume it or simply ignore it. But who knows, right?",
            "description": "Used when a variable is defined but might not be used. The possibility comes from the fact that locals() might be used, which could consume or not the said variable"
        },
        "W0642": {
            "name": "self-cls-assignment",
            "message": "Oh, great job assigning to 'self' or 'cls' in an instance or class method. That's definitely a clever move.",
            "description": "Invalid assignment to self or cls in instance or class method respectively."
        },
        "W0644": {
            "name": "unbalanced-dict-unpacking",
            "message": "Oh, how lovely to stumble upon this unbalanced dict unpacking in your assignment or for loop. Quite an interesting choice you've made there, leaving things all lopsided and off-kilter. Surely there must be some method to your madness, but I can't help but wonder if a bit more attention to detail might be in order.",
            "description": "Used when there is an unbalanced dict unpacking in assignment or for loop"
        },
        "W0149": {
            "name": "while-used",
            "message": "Oh, just a little reminder: unbounded `while` loops, you know, they can often (just often, you know) be rewritten as bounded `for` loops. But hey, I get it, there are some special cases where you might want to make exceptions, like event loops, listeners, and all that jazz. Just throwing it out there, you know, in case you're interested.",
            "description": "Unbounded `while` loops can often be rewritten as bounded `for` loops. Exceptions can be made for cases such as event loops, listeners, etc."
        }
    },
    "convention": {
        "C0121": {
            "name": "singleton-comparison",
            "message": "Oh, I see someone couldn't resist comparing their precious expression to those beloved singleton values like True, False or None. How clever.",
            "description": "Used when an expression is compared to singleton values like True, False or None."
        },
        "C0123": {
            "name": "unidiomatic-typecheck",
            "message": "Oh, just so you know, the \"idiomatic\" way to do an *explicit* typecheck in Python is to use isinstance(x, Y) instead of type(x) == Y or type(x) is Y. But hey, I guess there are some *unusual situations* where these methods can actually give different results. How fascinating, right?",
            "description": "The idiomatic way to perform an explicit typecheck in Python is to use isinstance(x, Y) rather than type(x) == Y, type(x) is Y. Though there are unusual situations where these give different results."
        },
        "C0112": {
            "name": "empty-docstring",
            "message": "Oh, how delightful! It appears that this module, function, class, or method has graced us with its presence, but alas, its docstring seems to be empty. How unchallenging it would have been to provide a thoughtful description (;",
            "description": "Used when a module, function, class or method has an empty docstring (it would be too easy ;)."
        },
        "C0114": {
            "name": "missing-module-docstring",
            "message": "Oh, how delightful! This module seems to have no docstring. But don't fret my dear, empty modules like this one simply do not need a docstring. Isn't that just marvelous?",
            "description": "Used when a module has no docstring. Empty modules do not require a docstring."
        },
        "C0115": {
            "name": "missing-class-docstring",
            "message": "Oh, how impressive! This incredible class seems to have no docstring whatsoever. But wait, don't worry! Even if you can't be bothered to provide any information about what this class does, remember that an empty class still deserves the luxury of having a docstring. Isn't that just marvelous?",
            "description": "Used when a class has no docstring. Even an empty class must have a docstring."
        },
        "C0116": {
            "name": "missing-function-docstring",
            "message": "Oh, how wonderful! It seems like someone forgot to include a docstring for this function or method. Just to clarify, certain special methods like __init__ are exempt from this requirement. But hey, who needs clear and descriptive documentation anyways, right?",
            "description": "Used when a function or method has no docstring. Some special methods like __init__ do not require a docstring."
        },
        "C0103": {
            "name": "invalid-name",
            "message": "Ah, so we've got a name here that completely disregards the well-established rules and guidelines for naming associated with its type. How wonderfully creative of you to come up with something so unique and nonconforming!",
            "description": "Used when the name doesn't conform to naming rules associated to its type (constant, variable, class...)."
        },
        "C0104": {
            "name": "disallowed-name",
            "message": "Oh, look at you using your little \"bad-names\" or \"bad-names-rgxs\"! How original and creative of you to choose unauthorized names. So impressive.",
            "description": "Used when the name matches bad-names or bad-names-rgxs- (unauthorized names)."
        },
        "C0105": {
            "name": "typevar-name-incorrect-variance",
            "message": "Oh, great job on not reflecting the type variance in your TypeVar name! I hope you're aware that according to PEP8, it's strongly recommended to add the suffixes '_co' and '_contra' to declare covariant or contravariant behavior. But hey, don't worry about it if you're just dealing with invariant variables. Oh, and by the way, if you do happen to add a suffix to an invariant variable, you'll get this message too. Just thought I'd let you know.",
            "description": "Emitted when a TypeVar name doesn't reflect its type variance. According to PEP8, it is recommended to add suffixes '_co' and '_contra' to the variables used to declare covariant or contravariant behaviour respectively. Invariant (default) variables do not require a suffix. The message is also emitted when invariant variables do have a suffix."
        },
        "C0131": {
            "name": "typevar-double-variance",
            "message": "Oh, isn't it just adorable when both the \"covariant\" and \"contravariant\" keyword arguments are set to \"True\" in a TypeVar? Like, congratulations on your unparalleled ability to completely contradict yourself! I mean, who needs consistency and logic, right? Keep up the good work!",
            "description": "Emitted when both the \"covariant\" and \"contravariant\" keyword arguments are set to \"True\" in a TypeVar."
        },
        "C0132": {
            "name": "typevar-name-mismatch",
            "message": "Oh, well I suppose someone didn't bother to match the TypeVar's name argument with the variable they assigned it to. Not the sharpest move, if you ask me.",
            "description": "Emitted when a TypeVar is assigned to a variable that does not match its name argument."
        },
        "C0202": {
            "name": "bad-classmethod-argument",
            "message": "Oh, I see you've decided to ignore the recommended convention of naming your first argument in a class method as \"cls\". How creative of you to choose a different name! It must be so delightful for others to easily differentiate your class methods from regular instance methods. Such originality!",
            "description": "Used when a class method has a first argument named differently than the value specified in valid-classmethod-first-arg option (default to \"cls\"), recommended to easily differentiate them from regular instance methods."
        },
        "C0203": {
            "name": "bad-mcs-method-argument",
            "message": "Oh, aren't we clever? Looks like someone decided to give a first argument in the metaclass method a name that's different from what's specified in the valid-classmethod-first-arg option. How unique and special! Just a little suggestion, though: maybe it's a good idea to have them named the same so that they stand out as regular instance methods. But hey, who am I to give advice? You do you!",
            "description": "Used when a metaclass method has a first argument named differently than the value specified in valid-classmethod-first-arg option (default to \"cls\"), recommended to easily differentiate them from regular instance methods."
        },
        "C0204": {
            "name": "bad-mcs-classmethod-argument",
            "message": "Oh, I see you have decided to name your first argument in the metaclass class method something other than the recommended \"mcs\" specified in the valid-metaclass-classmethod-first-arg option. How innovative of you! But just so you know, it is generally advised to stick to the conventions to easily distinguish metaclass class methods from regular instance methods. Just a friendly heads-up!",
            "description": "Used when a metaclass class method has a first argument named differently than the value specified in valid-metaclass-classmethod-first-arg option (default to \"mcs\"), recommended to easily differentiate them from regular instance methods."
        },
        "C0205": {
            "name": "single-string-used-for-slots",
            "message": "Oh, well look at this! Someone decided to use a simple string as a class __slots__ instead of an iterable. How clever! I'm sure that was a deliberate choice and definitely not a mistake at all. Fantastic job!",
            "description": "Used when a class __slots__ is a simple string, rather than an iterable."
        },
        "C2201": {
            "name": "misplaced-comparison-constant",
            "message": "Well, someone decided to place the constant on the left side of a comparison. It might be clearer to everyone else if it were on the right hand side instead. Just a thought.",
            "description": "Used when the constant is placed on the left side of a comparison. It is usually clearer in intent to place it in the right hand side of the comparison."
        },
        "C0501": {
            "name": "consider-using-any-or-all",
            "message": "Oh, look at this fancy for loop checking for a condition and returning a bool! I'm sure it thinks it's so clever. But just so you know, it could easily be replaced with the oh-so-much cooler any or all. Just saying.",
            "description": "A for loop that checks for a condition and return a bool can be replaced with any or all."
        },
        "C3401": {
            "name": "dict-init-mutate",
            "message": "Well, I'm sure you already know how to properly initialize dictionaries with just one statement using dictionary literal syntax. But hey, if I need to remind you, there you go.",
            "description": "Dictionaries can be initialized with a single statement using dictionary literal syntax."
        },
        "C0198": {
            "name": "bad-docstring-quotes",
            "message": "Oh, wonderful! We have a docstring that doesn't bother with those pesky triple double quotes. How innovative.",
            "description": "Used when a docstring does not have triple double quotes."
        },
        "C0199": {
            "name": "docstring-first-line-empty",
            "message": "Oh, how wonderful! A blank line has made its way to the beginning of a docstring. Absolutely brilliant.",
            "description": "Used when a blank line is found at the beginning of a docstring."
        },
        "C2701": {
            "name": "import-private-name",
            "message": "Wow, so impressive that you decided to import a private module or object prefixed with _. I mean, who needs to follow PEP8 guidance on Naming Conventions anyway? It clearly states that public attributes with leading underscores should be considered private, but hey, why bother?",
            "description": "Used when a private module or object prefixed with _ is imported. PEP8 guidance on Naming Conventions states that public attributes with leading underscores should be considered private."
        },
        "C0410": {
            "name": "multiple-imports",
            "message": "Oh, look who's feeling fancy with their multiple module imports! How unique and edgy of you to go against the norm. Maybe next time you can try to keep it simple like the rest of us. Just a friendly suggestion.",
            "description": "Used when import statement importing multiple modules is detected."
        },
        "C0411": {
            "name": "wrong-import-order",
            "message": "Oh, I see someone has decided to completely ignore the PEP8 import order guideline. I guess the concept of placing standard imports before third-party libraries and local imports is just too much to handle for some people. But hey, who needs consistency and organization anyway?",
            "description": "Used when PEP8 import order is not respected (standard imports first, then third-party libraries, then local imports)."
        },
        "C0412": {
            "name": "ungrouped-imports",
            "message": "Oh, how delightful! Another instance where imports were not properly grouped by packages. How curious it is that some folks just can't seem to adhere to such a simple guideline. But not to fret, dear coder, I'm sure you have your reasons for disregarding this charming little convention. Just reminding you, ever so politely, that it might be beneficial to organize your imports in a more elegant and logical manner by grouping them by packages. Such a trivial matter, really. But ah, the joys of conformity and consistency!",
            "description": "Used when imports are not grouped by packages."
        },
        "C0413": {
            "name": "wrong-import-position",
            "message": "Oh, so now we're just throwing imports into the code willy-nilly, huh? Nice organization skills you got there.",
            "description": "Used when code and imports are mixed."
        },
        "C0414": {
            "name": "useless-import-alias",
            "message": "Oh, how original! Using an import alias that is the exact same as the original package. I see you really put your thinking cap on for this one. It's not like we have established conventions for a reason, like using import numpy as np instead of import numpy as numpy. But hey, who needs clarity and readability, right? ",
            "description": "Used when an import alias is same as original package, e.g., using import numpy as numpy instead of import numpy as np."
        },
        "C0415": {
            "name": "import-outside-toplevel",
            "message": "It's adorable how you put your import statement anywhere other than the module toplevel. But please, do us all a favor and move it to the top of the file. Thanks!",
            "description": "Used when an import statement is used anywhere other than the module toplevel. Move this import to the top of the file."
        },
        "C0301": {
            "name": "line-too-long",
            "message": "Oh, how impressive! Looks like someone couldn't contain their brilliance within the limits of a normal line length. Too bad it had to be pointed out to them.",
            "description": "Used when a line is longer than a given number of characters."
        },
        "C0302": {
            "name": "too-many-lines",
            "message": "Oh, look at this module with its excessive number of lines, clearly trying to sabotage its own readability.",
            "description": "Used when a module has too many lines, reducing its readability."
        },
        "C0303": {
            "name": "trailing-whitespace",
            "message": "Oh, look at this clever use of whitespace. Clearly, someone must have wanted to make this code extra special by adding a little gap at the end. How thoughtful.",
            "description": "Used when there is whitespace between the end of a line and the newline."
        },
        "C0304": {
            "name": "missing-final-newline",
            "message": "Oh, so you forgot to add a newline at the end of the file. How original.",
            "description": "Used when the last line in a file is missing a newline."
        },
        "C0305": {
            "name": "trailing-newlines",
            "message": "Oh, looks like someone decided to leave some lovely trailing blank lines in this file. How thoughtful of them!",
            "description": "Used when there are trailing blank lines in a file."
        },
        "C0321": {
            "name": "multiple-statements",
            "message": "Oh, look at this! More than one statement crammed onto a single line. How charming.",
            "description": "Used when more than on statement are found on the same line."
        },
        "C0325": {
            "name": "superfluous-parens",
            "message": "Oh, look at this brilliant use of parentheses after an if, for, or other keyword. So unique and groundbreaking.",
            "description": "Used when a single item in parentheses follows an if, for, or other keyword."
        },
        "C0327": {
            "name": "mixed-line-endings",
            "message": "Oh, look! Someone thought it would be fun to mix things up by using both LF and CRLF newline signs in this file. How creative!",
            "description": "Used when there are mixed (LF and CRLF) newline signs in a file."
        },
        "C0328": {
            "name": "unexpected-line-ending-format",
            "message": "Oh, how nice, we have a different newline than we were expecting. How delightful.",
            "description": "Used when there is different newline than expected."
        },
        "C3001": {
            "name": "unnecessary-lambda-assignment",
            "message": "Oh, how original! Instead of defining a standard function with the \"def\" keyword like a normal person, you just had to go and assign a lambda expression to a variable. How cute.",
            "description": "Used when a lambda expression is assigned to variable rather than defining a standard function with the \"def\" keyword."
        },
        "C3002": {
            "name": "unnecessary-direct-lambda-call",
            "message": "Oh, how creative! Rather than executing the contents of a lambda expression inline, you've decided to directly call it instead. Impressive maneuver!",
            "description": "Used when a lambda expression is directly called rather than executing its contents inline."
        },
        "C2401": {
            "name": "non-ascii-name",
            "message": "Oh, by the way, it seems like someone decided to use a name with non-ASCII unicode characters. You might want to take a look at this link (https:\/\/peps.python.org\/pep-0672\/#confusing-features) to see why it's considered \"bad\". Just a friendly reminder, if your so-called programming guideline states that English is the way to go, it's probably best to avoid using non-ASCII characters in Python Names. If you're not on board with that, no worries, you can always disable this pesky little check. It's totally up to you!",
            "description": "Used when the name contains at least one non-ASCII unicode character. See https:\/\/peps.python.org\/pep-0672\/#confusing-features for a background why this could be bad. \nIf your programming guideline defines that you are programming in English, then there should be no need for non ASCII characters in Python Names. If not you can simply disable this check."
        },
        "C2403": {
            "name": "non-ascii-module-import",
            "message": "Oh, look at that! We have a name with at least one non-ASCII unicode character. How delightful! You might want to refer to this fascinating link (https:\/\/peps.python.org\/pep-0672\/#confusing-features) to understand why this could potentially be problematic. \nNow, if your programming guideline clearly states that you should be programming in English, it's quite baffling why you'd feel the urge to use non ASCII characters in Python names. But hey, no worries! You can always go ahead and disable this check if you can't resist the temptation. Have a marvelous day!",
            "description": "Used when the name contains at least one non-ASCII unicode character. See https:\/\/peps.python.org\/pep-0672\/#confusing-features for a background why this could be bad. \nIf your programming guideline defines that you are programming in English, then there should be no need for non ASCII characters in Python Names. If not you can simply disable this check."
        },
        "C1802": {
            "name": "use-implicit-booleaness-not-len",
            "message": "I just love how empty sequences are treated as false. You can totally get rid of that pesky 'len' call (``if not x``) or bother yourself with comparing the length to a scalar (``if len(x) > 1``). Totally your choice, no big deal!",
            "description": "Empty sequences are considered false in a boolean context. You can either remove the call to 'len' (``if not x``) or compare the length against ascalar (``if len(x) > 1``)."
        },
        "C1803": {
            "name": "use-implicit-booleaness-not-comparison",
            "message": "Oh, hey there! Just thought I'd remind you that empty sequences are, like, totally false in a boolean context. You know, in case you were wondering. But, uh, be careful when blindly following this check in a weakly typed code base because it can cause these super fun, hard-to-debug issues. I mean, who doesn't love those? Oh, and here's a fab tip: if the value could be something else that's falsey but not a sequence, like, I don't know, `None`, an empty string, or `0`, well then guess what? The code won't actually be equivalent. So, yeah, just throwing that out there for ya. Enjoy!",
            "description": "Empty sequences are considered false in a boolean context. Following this check blindly in weakly typed code base can create hard to debug issues. If the value can be something else that is falsey but not a sequence (for example ``None``, an empty string, or ``0``) the code will not be equivalent."
        },
        "C1804": {
            "name": "use-implicit-booleaness-not-comparison-to-string",
            "message": "Oh, just thought I'd let you know that empty strings are totally like, FALSE, you know? So like, you better watch out, because if you're blindly following this check in some weakly typed code base, be prepared for some super hard to debug issues. I mean, if the value can be something else that's kinda falsey, but not like a string (like, say, ``None``, an empty sequence, or even ``0``), well then guess what? Yeah, the code won't even be equivalent. Oopsie daisy!",
            "description": "Empty string are considered false in a boolean context. Following this check blindly in weakly typed code base can create hard to debug issues. If the value can be something else that is falsey but not a string (for example ``None``, an empty sequence, or ``0``) the code will not be equivalent."
        },
        "C1805": {
            "name": "use-implicit-booleaness-not-comparison-to-zero",
            "message": "Oh, how convenient! It seems that someone here is blindly following a certain check in our weakly typed code base without considering the potential consequences. Little do they know that this reckless behavior can lead to frustrating and difficult-to-debug issues. Sure, sure, the value might be something other than an integer that evaluates to false, like \"None\", an empty string, or an empty sequence. But who cares about equivalent code, right? Good luck with that!",
            "description": "0 is considered false in a boolean context. Following this check blindly in weakly typed code base can create hard to debug issues. If the value can be something else that is falsey but not an int (for example ``None``, an empty string, or an empty sequence) the code will not be equivalent."
        },
        "C0200": {
            "name": "consider-using-enumerate",
            "message": "Oh, look who's using the ancient range and len combo! Did you know there's a little thing called the enumerate builtin that could simplify your life? But hey, who am I to suggest a more efficient solution? Just thought I'd mention it.",
            "description": "Emitted when code that iterates with range and len is encountered. Such code can be simplified by using the enumerate builtin."
        },
        "C0201": {
            "name": "consider-iterating-dictionary",
            "message": "I guess you could use the `.keys()` method or check for membership using `if key in dictionary`, but why bother? It's not like it's faster or anything. But hey, it's your choice! Just thought I'd let you know.",
            "description": "Emitted when the keys of a dictionary are iterated through the ``.keys()`` method or when ``.keys()`` is used for a membership check. It is enough to iterate through the dictionary itself, ``for key in dictionary``. For membership checks, ``if key in dictionary`` is faster."
        },
        "C0206": {
            "name": "consider-using-dict-items",
            "message": "Oh, I see you're trying to be clever by iterating over the keys of a dictionary and accessing the value by index lookup. Well, let me just inform you that you can actually access both the key and value by simply iterating using the .items() method of the dictionary instead. But hey, feel free to complicate things unnecessarily if you really want to.",
            "description": "Emitted when iterating over the keys of a dictionary and accessing the value by index lookup. Both the key and value can be accessed by iterating using the .items() method of the dictionary instead."
        },
        "C0207": {
            "name": "use-maxsplit-arg",
            "message": "Oh, congratulations! You just accessed only the first or last element of str.split(). In case you weren't aware, you could have accessed those elements by simply using str.split(sep, maxsplit=1)[0] or str.rsplit(sep, maxsplit=1)[-1] instead. But hey, it's your choice. Keep doing things the hard way if you prefer.",
            "description": "Emitted when accessing only the first or last element of str.split(). The first and last element can be accessed by using str.split(sep, maxsplit=1)[0] or str.rsplit(sep, maxsplit=1)[-1] instead."
        },
        "C0208": {
            "name": "use-sequence-for-iteration",
            "message": "Oh, just a small hint for you - in case you didn't know, sequence types like \"lists\", \"tuples\", and \"ranges\" might be a tad more efficient than \"sets\" when it comes to iterating over values. But hey, I'm sure you already knew that, right? Just thought I'd mention it, in case it somehow slipped your mind. Have a great day!",
            "description": "When iterating over values, sequence types (e.g., ``lists``, ``tuples``, ``ranges``) are more efficient than ``sets``."
        },
        "C0209": {
            "name": "consider-using-f-string",
            "message": "Oh, look at this fancy code over here using outdated string formatting methods like format() or %. Don't you know that f-strings are all the rage now? You better update your Python version and start using them if you want to be part of the cool kids club. But hey, who am I to judge? It's not like f-strings are a preferred choice or anything. Just saying.",
            "description": "Used when we detect a string that is being formatted with format() or % which could potentially be an f-string. The use of f-strings is preferred. Requires Python 3.6 and ``py-version >= 3.6``."
        },
        "C0113": {
            "name": "unneeded-not",
            "message": "Oh, how wonderful! The boolean expression just couldn't resist adding an unnecessary negation. How utterly delightful!",
            "description": "Used when a boolean expression contains an unneeded negation."
        },
        "C0401": {
            "name": "wrong-spelling-in-comment",
            "message": "Oh, how marvelous! Looks like someone had a little oopsie with their spelling. Time to break out the dictionary and sharpen up those language skills, my friend.",
            "description": "Used when a word in comment is not spelled correctly."
        },
        "C0402": {
            "name": "wrong-spelling-in-docstring",
            "message": "Well, it seems like someone didn't bother to double-check their spelling in the docstring. Quite an impressive display of carelessness, I must say.",
            "description": "Used when a word in docstring is not spelled correctly."
        },
        "C0403": {
            "name": "invalid-characters-in-docstring",
            "message": "Oh, look at this! Enchant can't even check a single word in the docstring. How impressive.",
            "description": "Used when a word in docstring cannot be checked by enchant."
        },
        "C2503": {
            "name": "bad-file-encoding",
            "message": "Oh, look at that. PEP8 ever so kindly \"suggests\" using UTF-8 as the default encoding for Python files. I mean, it's not like it's mandatory or anything. Just a friendly little recommendation. If you're interested, you can check out the link here: https:\/\/peps.python.org\/pep-0008\/#source-file-encoding. But hey, who really cares about following best practices, right?",
            "description": "PEP8 recommends UTF-8 default encoding for Python files. See https:\/\/peps.python.org\/pep-0008\/#source-file-encoding"
        },
        "C2801": {
            "name": "unnecessary-dunder-call",
            "message": "Oh, congratulations on manually calling a dunder method instead of using the corresponding function\/method\/operator. How innovative of you!",
            "description": "Used when a dunder method is manually called instead of using the corresponding function\/method\/operator."
        }
    },
    "refactor": {
        "R0022": {
            "name": "useless-option-value",
            "message": "Oh, look who's using an option that doesn't even exist anymore! How cute!",
            "description": "Used when a value for an option that is now deleted from pylint is encountered."
        },
        "R0123": {
            "name": "literal-comparison",
            "message": "Oh, isn't it just lovely when you compare an object to a literal instead of what was actually expected? Because who needs accurate comparisons when you can merrily compare things to completely different literals altogether?",
            "description": "Used when comparing an object to a literal, which is usually what you do not want to do, since you can compare to a different literal than what was expected altogether."
        },
        "R0124": {
            "name": "comparison-with-itself",
            "message": "Oh, how interesting! Here we have a comparison against oneself. How clever!",
            "description": "Used when something is compared against itself."
        },
        "R0133": {
            "name": "comparison-of-constants",
            "message": "Oh, just a friendly reminder: did you know that when comparing two literals, you actually get a constant as a result? Pretty cool, right? Using that constant directly instead of initializing 'True' and 'False' is not really necessary anymore. But hey, it's your choice, go ahead and complicate things if you want. Just thought you might like to know. Keep rocking!",
            "description": "When two literals are compared with each other the result is a constant. Using the constant directly is both easier to read and more performant. Initializing 'True' and 'False' this way is not required since Python 2.3."
        },
        "R0202": {
            "name": "no-classmethod-decorator",
            "message": "Oh how cute, a class method defined without utilizing the decorator syntax. Guess somebody missed the memo on proper coding practices.",
            "description": "Used when a class method is defined without using the decorator syntax."
        },
        "R0203": {
            "name": "no-staticmethod-decorator",
            "message": "Oh, so I see we decided to define a static method without bothering to use the decorator syntax. How quaint.",
            "description": "Used when a static method is defined without using the decorator syntax."
        },
        "R0205": {
            "name": "useless-object-inheritance",
            "message": "Oh, how interesting! Just thought I'd let you know that you've gone ahead and inherited from object, which is actually unnecessary under python3. But hey, feel free to keep it if you want to! Just thought I'd point it out. Have a lovely day!",
            "description": "Used when a class inherit from object, which under python3 is implicit, hence can be safely removed from bases."
        },
        "R0206": {
            "name": "property-with-parameters",
            "message": "Oh, how convenient! We just love it when we stumble upon properties with pointless parameters. Because, you know, who needs to call properties with any extra arguments? It's not like that's a thing, right? Just so useless, really.",
            "description": "Used when we detect that a property also has parameters, which are useless, given that properties cannot be called with additional arguments."
        },
        "R6101": {
            "name": "consider-using-namedtuple-or-dataclass",
            "message": "Oh, look who thinks they're so smart! Just wanted to let you know that instead of using those plain old dictionary values, you could totally upgrade to using namedtuples or dataclass instances. But you know, no big deal if you don't want to join the rest of us in the modern programming world. Just thought I'd mention it!",
            "description": "Emitted when dictionary values can be replaced by namedtuples or dataclass instances."
        },
        "R6102": {
            "name": "consider-using-tuple",
            "message": "Well, if you really want to maintain style consistency, go ahead and replace that in-place defined \"list\" with a \"tuple\". It's not like it's going to make any difference in performance anyway, thanks to those super-efficient optimizations by CPython. But hey, don't let that stop you from wasting your time!",
            "description": "Only for style consistency! Emitted where an in-place defined ``list`` can be replaced by a ``tuple``. Due to optimizations by CPython, there is no performance benefit from it."
        },
        "R6103": {
            "name": "consider-using-assignment-expr",
            "message": "It would be absolutely fantastic if you could spare a moment to consider combining the if assignment and if statement using the assignment expression `:=`. It's only possible if your Python version is 3.8 or above, and of course, if `py-version >= 3.8` as well. But hey, it's totally up to you. Just a friendly suggestion.",
            "description": "Emitted when an if assignment is directly followed by an if statement and both can be combined by using an assignment expression ``:=``. Requires Python 3.8 and ``py-version >= 3.8``."
        },
        "R6104": {
            "name": "consider-using-augmented-assign",
            "message": "Oh, look at you! You decided to refer to the object you are assigning to. How cute! Just so you know, you could change it to be an augmented assign instead. But hey, who am I to tell you what to do? Oh, by the way, this warning is disabled by default! So, feel free to ignore it if you want. Keep up the great work!",
            "description": "Emitted when an assignment is referring to the object that it is assigning to. This can be changed to be an augmented assign.\nDisabled by default!"
        },
        "R6105": {
            "name": "prefer-typing-namedtuple",
            "message": "It's absolutely fascinating how 'typing.NamedTuple' dares to utilize the widely recognized 'class' keyword with type-hints for the sake of readability (and let's not forget that it's faster than an internal exec call). But oh well, it's disabled by default! Such a pity!",
            "description": "'typing.NamedTuple' uses the well-known 'class' keyword with type-hints for readability (it's also faster as it avoids an internal exec call).\nDisabled by default!"
        },
        "R5601": {
            "name": "confusing-consecutive-elif",
            "message": "Oh, would you look at that! An elif statement, right after an indented block that conveniently ends with if or elif. I mean, who knows if it was done intentionally or just a silly little mistake? It's not like anyone can tell, right? But hey, here's a suggestion, why not extract that indented if statement and put it in its own shiny little function? You know, just to save everyone from all the confusion and potential errors. Up to you though!",
            "description": "Used when an elif statement follows right after an indented block which itself ends with if or elif. It may not be ovious if the elif statement was willingly or mistakenly unindented. Extracting the indented if statement into a separate function might avoid confusion and prevent errors."
        },
        "R3501": {
            "name": "consider-refactoring-into-while-condition",
            "message": "It would be sooo much better if you didn't use a `while True:` loop with the first statement as a break condition. Come on, just remove that unnecessary ``if \/ break`` construct and invert the check, then move it to the ``while`` statement. It's not rocket science!",
            "description": "Emitted when `while True:` loop is used and the first statement is a break condition. The ``if \/ break`` construct can be removed if the check is inverted and moved to the ``while`` statement."
        },
        "R5501": {
            "name": "else-if-used",
            "message": "Oh, look at this clever little else statement followed by an if statement! How convenient that it doesn't contain any unrelated statements. So thoughtful of you.",
            "description": "Used when an else statement is immediately followed by an if statement and does not contain statements that would be unrelated to it."
        },
        "R2044": {
            "name": "empty-comment",
            "message": "Oh, look! A # symbol on a line without an actual comment. How fascinating!",
            "description": "Used when a # symbol appears on a line not followed by an actual comment"
        },
        "R0401": {
            "name": "cyclic-import",
            "message": "Oh, look what we have here! Seems like someone's gone and created a nice little cyclic import between two or more modules. How thoughtful!",
            "description": "Used when a cyclic import between two or more modules is detected."
        },
        "R0402": {
            "name": "consider-using-from-import",
            "message": "Oh, how impressive! Looks like someone decided to import a submodule of a package and alias it with the same name. How clever! Just so you know, it's recommended to use the \"from <module> import <submodule>\" syntax instead. But hey, who am I to tell you how to write your code? Good luck with your unconventional approach!",
            "description": "Emitted when a submodule of a package is imported and aliased with the same name, e.g., instead of ``import concurrent.futures as futures`` use ``from concurrent import futures``."
        },
        "R1260": {
            "name": "too-complex",
            "message": "Oh, well, would you look at that! It seems like someone has gone and made this method or function just a tad too complex according to good ol' McCabe Complexity Cyclomatic. But hey, who needs simplicity and readability, am I right?",
            "description": "Used when a method or function is too complex based on McCabe Complexity Cyclomatic"
        },
        "R0901": {
            "name": "too-many-ancestors",
            "message": "Oh, looks like someone got a bit carried away with the parent classes here. Maybe it's time to untangle the mess and simplify this class. You know, so that it becomes easier for mere mortals like us to actually use it. Just a suggestion!",
            "description": "Used when class has too many parent classes, try to reduce this to get a simpler (and so easier to use) class."
        },
        "R0902": {
            "name": "too-many-instance-attributes",
            "message": "Oh, congratulations on creating a class with an overwhelming number of instance attributes! Maybe you should consider reducing them to make it a tad simpler and, you know, actually user-friendly. But hey, no rush, take your sweet time.",
            "description": "Used when class has too many instance attributes, try to reduce this to get a simpler (and so easier to use) class."
        },
        "R0903": {
            "name": "too-few-public-methods",
            "message": "I can't help but notice that this class seems to have an unusually scarce number of public methods. But hey, who am I to question your decision-making? Just make sure it's truly worth it, and not, you know, a colossal waste of time.",
            "description": "Used when class has too few public methods, so be sure it's really worth it."
        },
        "R0904": {
            "name": "too-many-public-methods",
            "message": "Wow, looks like someone went wild and threw a bunch of public methods into this class! Maybe consider reducing them to make this class less of a headache to use. Just a friendly suggestion, of course.",
            "description": "Used when class has too many public methods, try to reduce this to get a simpler (and so easier to use) class."
        },
        "R0911": {
            "name": "too-many-return-statements",
            "message": "Well, isn't this just a delightful mess we have here? Seems like someone got a little too carried away with their return statements, making it nearly impossible to understand what the heck is going on. Bravo.",
            "description": "Used when a function or method has too many return statement, making it hard to follow."
        },
        "R0912": {
            "name": "too-many-branches",
            "message": "It might be a bit challenging to understand the logic here with all the countless branches in this function or method. But hey, good luck trying to follow along!",
            "description": "Used when a function or method has too many branches, making it hard to follow."
        },
        "R0913": {
            "name": "too-many-arguments",
            "message": "So apparently the function or method thinks it's okay to take ALL the arguments. It's not like we all have things to do and don't want to sit here all day waiting for it to finish. But hey, who needs efficiency anyway?",
            "description": "Used when a function or method takes too many arguments."
        },
        "R0914": {
            "name": "too-many-locals",
            "message": "Oh, look at all these lovely local variables in this function or method. It's almost like someone was trying to break a record for the most cluttered code. How charming.",
            "description": "Used when a function or method has too many local variables."
        },
        "R0915": {
            "name": "too-many-statements",
            "message": "Oh look, someone thought it would be cute to write a function or method with a gazillion statements. Maybe we should consider splitting it into smaller functions or methods because apparently, brevity is not their strong suit. Just a little friendly advice.",
            "description": "Used when a function or method has too many statements. You should then split it in smaller functions \/ methods."
        },
        "R0916": {
            "name": "too-many-boolean-expressions",
            "message": "Oh, how marvelous! Just a teensy bit of helpful advice: it appears that your if statement might be ever so slightly overloaded with boolean expressions. Perhaps it could benefit from a wee bit of simplification? Just a thought!",
            "description": "Used when an if statement contains too many boolean expressions."
        },
        "R2004": {
            "name": "magic-value-comparison",
            "message": "It would be so nice if someone could bother to use named constants instead of those oh-so-magical values. It's just a suggestion, but it might actually make your code readable and maintainable. Oh, but feel free to ignore it, if you don't really care about that kind of stuff.",
            "description": "Using named constants instead of magic values helps improve readability and maintainability of your code, try to avoid them in comparisons."
        },
        "R0204": {
            "name": "redefined-variable-type",
            "message": "Oh, look who decided to change the type of a variable inside a method or a function. How nice of you to mix things up and confuse everyone else.",
            "description": "Used when the type of a variable changes inside a method or a function."
        },
        "R6301": {
            "name": "no-self-use",
            "message": "Well, it seems like this method has completely forgotten about its bound instance. Maybe it just wants to be a function instead? Who knows?",
            "description": "Used when a method doesn't use its bound instance, and so could be written as a function."
        },
        "R1701": {
            "name": "consider-merging-isinstance",
            "message": "\"Oh, so you thought it was necessary to use separate isinstance calls instead of merging them into one? How creative!\"",
            "description": "Used when multiple consecutive isinstance calls can be merged into one."
        },
        "R1702": {
            "name": "too-many-nested-blocks",
            "message": "Oh, looks like someone went a little crazy with the nesting in this function or method. It's kind of hard to follow and maintain now, don't you think? Just a thought.",
            "description": "Used when a function or a method has too many nested blocks. This makes the code less understandable and maintainable."
        },
        "R1703": {
            "name": "simplifiable-if-statement",
            "message": "Oh, how convenient! We could easily replace that if statement with 'bool(test)'. Just a friendly suggestion, in case you were interested in saving some valuable keystrokes. But hey, it's your choice, do whatever you want!",
            "description": "Used when an if statement can be replaced with 'bool(test)'."
        },
        "R1704": {
            "name": "redefined-argument-from-local",
            "message": "Oh, look who thinks they know better than the programmer! Apparently, a local name is redefining an argument, which might lead to some kind of mistake. Just so you know, this is only considered in a few situations like iteration or when assigning in a with statement or exception handler. But hey, I'm sure you've got it all under control, right?",
            "description": "Used when a local name is redefining an argument, which might suggest a potential error. This is taken in account only for a handful of name binding operations, such as for iteration, with statement assignment and exception handler assignment."
        },
        "R1705": {
            "name": "no-else-return",
            "message": "Oh, look, another unnecessary block of code following an if statement with a return statement. How delightful. Brace yourselves for a warning if you dare to put an else after a series of ifs with return statements.",
            "description": "Used in order to highlight an unnecessary block of code following an if containing a return statement. As such, it will warn when it encounters an else following a chain of ifs, all of them containing a return statement."
        },
        "R1706": {
            "name": "consider-using-ternary",
            "message": "Oh, so we're still using pre-python 2.5 ternary syntax here, huh? How quaint.",
            "description": "Used when one of known pre-python 2.5 ternary syntax is used."
        },
        "R1707": {
            "name": "trailing-comma-tuple",
            "message": "Oh, just a friendly reminder: in Python, a tuple is surprisingly brought to life by the comma symbol, not the parentheses. But, and this is just a tiny detail you might have missed, you can accidentally create a tuple by carelessly misplacing a trailing comma. It's a real treat, let me tell you, because then you open the door to all sorts of delightful, unpredictable bugs in your precious code. So, just thought I'd mention, if you want to avoid these, you might want to consider using parentheses explicitly when summoning a tuple. But hey, no pressure! It's your code, after all!",
            "description": "In Python, a tuple is actually created by the comma symbol, not by the parentheses. Unfortunately, one can actually create a tuple by misplacing a trailing comma, which can lead to potential weird bugs in your code. You should always use parentheses explicitly for creating a tuple."
        },
        "R1708": {
            "name": "stop-iteration-return",
            "message": "Oh, I see we have another genius who doesn't bother to read the PEP479. Apparently, raising StopIteration to end the loop of a generator might, just might, result in some pesky bugs that are an absolute delight to find. But hey, no worries, this darling PEP clearly states that you should replace that delightful raise StopIteration with a ridiculously simple return statement. Don't strain yourself now, will you?",
            "description": "According to PEP479, the raise of StopIteration to end the loop of a generator may lead to hard to find bugs. This PEP specify that raise StopIteration has to be replaced by a simple return statement"
        },
        "R1709": {
            "name": "simplify-boolean-expression",
            "message": "Oh, look who's still using redundant pre-python 2.5 ternary syntax. How quaint.",
            "description": "Emitted when redundant pre-python 2.5 ternary syntax is used."
        },
        "R1710": {
            "name": "inconsistent-return-statements",
            "message": "Oh, I see we're not familiar with PEP8 guidelines here. According to PEP8, which we should definitely follow for better code readability and maintainability (not that it's important or anything), it states that if any return statement returns an expression, any return statements where no value is returned should explicitly state this as return None. Oh, and let's not forget the explicit return statement at the end of the function, just in case someone here doesn't know what they're doing and forgets about it. You know, it's only a good practice if we care about our code quality (but who cares, right?).",
            "description": "According to PEP8, if any return statement returns an expression, any return statements where no value is returned should explicitly state this as return None, and an explicit return statement should be present at the end of the function (if reachable)"
        },
        "R1711": {
            "name": "useless-return",
            "message": "Oh, how lovely to find a solitary \"return\" or \"return None\" statement lingering at the end of your function or method definition. It's simply enchanting that you felt the need to explicitly state the obvious, but fret not, for Python will kindly take care of returning None for you implicitly. So, feel free to remove this unnecessary line and bask in the elegance of simplifying your code.",
            "description": "Emitted when a single \"return\" or \"return None\" statement is found at the end of function or method definition. This statement can safely be removed because Python will implicitly return None"
        },
        "R1712": {
            "name": "consider-swap-variables",
            "message": "Oh, it seems like someone here is not aware that using a temporary variable to swap variables is not the only way to do it. Just a little heads up, utilizing \"tuple unpacking\" actually makes your intention much clearer. But hey, you do you!",
            "description": "You do not have to use a temporary variable in order to swap variables. Using \"tuple unpacking\" to directly swap variables makes the intention more clear."
        },
        "R1713": {
            "name": "consider-using-join",
            "message": "Well, if you're into wasting time, hogging memory, and making code harder to read, then by all means, go ahead and use a for-loop iteration instead of the much more efficient and readable str.join(sequence). Your call.",
            "description": "Using str.join(sequence) is faster, uses less memory and increases readability compared to for-loop iteration."
        },
        "R1714": {
            "name": "consider-using-in",
            "message": "Well, isn't it just fascinating to discover that instead of mindlessly comparing a variable to multiple values one by one, you could actually bother to gather them into a set or tuple and politely inquire whether said variable is contained \"in\" it? Oh, but don't worry, it's not just faster, it's also marvelously less verbose. Who would have thought!",
            "description": "To check if a variable is equal to one of many values, combine the values into a set or tuple and check if the variable is contained \"in\" it instead of checking for equality against each of the values. This is faster and less verbose."
        },
        "R1715": {
            "name": "consider-using-get",
            "message": "Oh, I see you're still using the old-fashioned method of accessing dictionary values. It's alright, I guess, but just so you're aware, using the built-in dict.get is actually considered more \"modern\" and \"in vogue.\" It may be a tad slower, but who cares about that? Just thought I'd point it out, in case you want to stay up-to-date with the cool kids.",
            "description": "Using the builtin dict.get for getting a value from a dictionary if a key is present or a default if not, is simpler and considered more idiomatic, although sometimes a bit slower"
        },
        "R1716": {
            "name": "chained-comparison",
            "message": "Oh, look what we have here! Pylint just couldn't resist giving its unsolicited advice. Apparently, it doesn't appreciate boolean operations such as \"a < b and b < c\". No, no, according to Mr. Pylint, we should all just drop everything and rush to refactor it to \"a < b < c\". Heaven forbid we challenge its superior coding standards!",
            "description": "This message is emitted when pylint encounters boolean operation like \"a < b and b < c\", suggesting instead to refactor it to \"a < b < c\""
        },
        "R1717": {
            "name": "consider-using-dict-comprehension",
            "message": "Oh, look at this! We have detected the creation of a dictionary using the dict() callable and a transient list. How innovative. Sure, there is technically nothing wrong with this code, but I must say, it is quite difficult to read and could use some simplification. Have you considered using a dict comprehension? Not only would it make your code more readable, but it would also be faster! You wouldn't need to create yet another transient list. Just a thought!",
            "description": "Emitted when we detect the creation of a dictionary using the dict() callable and a transient list. Although there is nothing syntactically wrong with this code, it is hard to read and can be simplified to a dict comprehension. Also it is faster since you don't need to create another transient list"
        },
        "R1718": {
            "name": "consider-using-set-comprehension",
            "message": "Congratulations on writing code that is grammatically correct! However, it appears to be unnecessarily convoluted and could benefit from some simplification. Perhaps consider using a set comprehension instead, as it would not only make the code more readable but also more efficient by eliminating the need to create an additional temporary list. But hey, it's your code, do with it what you will!",
            "description": "Although there is nothing syntactically wrong with this code, it is hard to read and can be simplified to a set comprehension. Also it is faster since you don't need to create another transient list"
        },
        "R1719": {
            "name": "simplifiable-if-expression",
            "message": "Oh, look! Another opportunity to use 'bool(test)' or 'test' instead of this if expression. How delightful! I can't think of a better way to waste my time than pointing this out.",
            "description": "Used when an if expression can be replaced with 'bool(test)' or simply 'test' if the boolean cast is implicit."
        },
        "R1720": {
            "name": "no-else-raise",
            "message": "Oh, isn't this just delightful? We've stumbled upon yet another unnecessary block of code, right after an if statement with a raise statement. How quaint! So, just a heads up, if you happen to come across an else statement following a whirlwind of ifs, all with raise statements, expect a little warning from yours truly. Enjoy your journey through this magnificent codebase!",
            "description": "Used in order to highlight an unnecessary block of code following an if containing a raise statement. As such, it will warn when it encounters an else following a chain of ifs, all of them containing a raise statement."
        },
        "R1721": {
            "name": "unnecessary-comprehension",
            "message": "You know, if you really wanted to go the extra mile, you could consider using the list, dict, or set constructor instead of that identity comprehension thing you got going on. Just saying, it's faster and simpler, but hey, what do I know?",
            "description": "Instead of using an identity comprehension, consider using the list, dict or set constructor. It is faster and simpler."
        },
        "R1722": {
            "name": "consider-using-sys-exit",
            "message": "Oh, look at you using 'sys.exit' instead of 'exit()' or 'quit()'. How original. Just FYI, 'sys.exit' doesn't depend on the site module being available because, you know, the 'sys' module is always there. But I'm sure you already knew that, right?",
            "description": "Contrary to 'exit()' or 'quit()', 'sys.exit' does not rely on the site module being available (as the 'sys' module is always available)."
        },
        "R1723": {
            "name": "no-else-break",
            "message": "Oh, look! Another instance of needless code! This linter just loves finding else statements after a whole series of ifs with break statements. It's almost like it's begging for a reason to complain.",
            "description": "Used in order to highlight an unnecessary block of code following an if containing a break statement. As such, it will warn when it encounters an else following a chain of ifs, all of them containing a break statement."
        },
        "R1724": {
            "name": "no-else-continue",
            "message": "Oh, look at this unnecessary block of code here, acting all fancy after an if statement with a continue. I'm just gonna go ahead and warn you whenever I see an else after a chain of ifs, especially if all of them have a continue. Just to make your life a little more difficult, you know?",
            "description": "Used in order to highlight an unnecessary block of code following an if containing a continue statement. As such, it will warn when it encounters an else following a chain of ifs, all of them containing a continue statement."
        },
        "R1725": {
            "name": "super-with-arguments",
            "message": "Oh, look who thinks they're so clever by explicitly mentioning that the super() builtin is being called with the current class and instance. Just so you know, on Python 3, those arguments are the default and can be omitted. But I guess you just had to go out of your way to point out the obvious, didn't you?",
            "description": "Emitted when calling the super() builtin with the current class and instance. On Python 3 these arguments are the default and they can be omitted."
        },
        "R1726": {
            "name": "simplifiable-condition",
            "message": "Oh, look at that! A boolean condition that could have been simplified. Fancy that!",
            "description": "Emitted when a boolean condition is able to be simplified."
        },
        "R1727": {
            "name": "condition-evals-to-constant",
            "message": "Oh, look at that! We have a boolean condition that can magically be simplified to a constant value. How fascinating!",
            "description": "Emitted when a boolean condition can be simplified to a constant value."
        },
        "R1728": {
            "name": "consider-using-generator",
            "message": "\"Using a generator for improved performance may be a wise option, unless you prefer your container to be excessively enormous.\"",
            "description": "If your container can be large using a generator will bring better performance."
        },
        "R1729": {
            "name": "use-a-generator",
            "message": "Well, if you were aiming for inefficiency and unnecessary verbosity, then sure, go ahead and use comprehension inside of 'any', 'all', 'max', 'min' or 'sum'. But hey, just thought I'd let you know that a much more efficient and faster solution would be to use a generator. Just a friendly suggestion!",
            "description": "Comprehension inside of 'any', 'all', 'max', 'min' or 'sum' is unnecessary. A generator would be sufficient and faster."
        },
        "R1730": {
            "name": "consider-using-min-builtin",
            "message": "It would be great if someone could take the time to use the min builtin instead of a conditional. It has been proven to improve readability and conciseness, but I guess some people just don't care about that.",
            "description": "Using the min builtin instead of a conditional improves readability and conciseness."
        },
        "R1731": {
            "name": "consider-using-max-builtin",
            "message": "Oh, using the max builtin instead of a conditional, that's one way to go. It surely makes the code a bit more readable and concise, but hey, who needs that anyway? Keep doing what you're doing.",
            "description": "Using the max builtin instead of a conditional improves readability and conciseness."
        },
        "R1732": {
            "name": "consider-using-with",
            "message": "It would be absolutely marvelous if you could potentially consider replacing your resource-allocating assignment or call with a 'with' block. You see, by making such a change, we can ensure the release of all the oh-so-important allocated resources, even in the unfortunate event of an exception. Just a thought, though!",
            "description": "Emitted if a resource-allocating assignment or call may be replaced by a 'with' block. By using 'with' the release of the allocated resources is ensured even in the case of an exception."
        },
        "R1733": {
            "name": "unnecessary-dict-index-lookup",
            "message": "Oh, great job accessing the value by index lookup when iterating over dictionary items! Just wanted to let you know that you could have accessed the value directly instead. But hey, you do you!",
            "description": "Emitted when iterating over the dictionary items (key-item pairs) and accessing the value by index lookup. The value can be accessed directly instead."
        },
        "R1734": {
            "name": "use-list-literal",
            "message": "Oh, how marvelous! Another instance of someone choosing the cumbersome, elongated route of using list() to create an empty list instead of simply opting for the much speedier, more efficient option of []! How utterly delightful! I mean, who has time for an extra function call when there's a perfectly fine literal just begging to be utilized? But, hey, you do you.",
            "description": "Emitted when using list() to create an empty list instead of the literal []. The literal is faster as it avoids an additional function call."
        },
        "R1735": {
            "name": "use-dict-literal",
            "message": "Oh, how delightful to see that you've opted for using dict() instead of the much speedier option of a literal '{ ... }' to create a dictionary. Surely, adding that extra function call couldn't have been intentional, could it? But fear not, I'm here to kindly inform you that using the literal would have been a much wiser choice in terms of performance. After all, why bother with efficiency when you can take the scenic route, right?",
            "description": "Emitted when using dict() to create a dictionary instead of a literal '{ ... }'. The literal is faster as it avoids an additional function call."
        },
        "R1736": {
            "name": "unnecessary-list-index-lookup",
            "message": "Oh, here's another one of those moments when someone just loves to iterate over an enumeration and access the value by index lookup. But hey, did you know that the value can actually be accessed directly? Just thought I'd mention it in case someone finds it useful. But hey, you do you!",
            "description": "Emitted when iterating over an enumeration and accessing the value by index lookup. The value can be accessed directly instead."
        },
        "R6201": {
            "name": "use-set-for-membership",
            "message": "Performing membership tests on a lookup optimized datatype like \"sets\" would save you loads of time, but hey, it's your call.",
            "description": "Membership tests are more efficient when performed on a lookup optimized datatype like ``sets``."
        },
        "R0801": {
            "name": "duplicate-code",
            "message": "Oh, looky here. Seems like we've got ourselves a collection of identical lines spread across multiple files. How intriguing! You know what that means, right? It's refactoring time! We should probably consider doing something about this detailed duplication issue of ours.",
            "description": "Indicates that a set of similar lines has been detected among multiple file. This usually means that the code should be refactored to avoid this duplication."
        },
        "R6002": {
            "name": "consider-using-alias",
            "message": "Oh, look who's using a deprecated typing alias in a type annotation context for Python 3.7 or 3.8, and all while having 'runtime-typing=no'! How original and clever! You never fail to impress with your outdated choices.",
            "description": "Only emitted if 'runtime-typing=no' and a deprecated typing alias is used in a type annotation context in Python 3.7 or 3.8."
        },
        "R6003": {
            "name": "consider-alternative-union-syntax",
            "message": "Oh, look who's reinventing the wheel with their fancy 'typing.Union' and 'typing.Optional' usage! Why bother with those when we have the perfectly fine 'int | None' syntax available? Just trying to be different, huh?",
            "description": "Emitted when 'typing.Union' or 'typing.Optional' is used instead of the alternative Union syntax 'int | None'."
        },
        "R6006": {
            "name": "redundant-typehint-argument",
            "message": "Hmm, it seems like `mypy` tool doesn't appreciate duplicated type arguments and will simply skip them. So, if you don't want to be confused or anything, you might want to consider removing those duplicated type arguments. Just a little suggestion, no need to take it seriously or anything.",
            "description": "Duplicated type arguments will be skipped by `mypy` tool, therefore should be removed to avoid confusion."
        }
    },
    "information": {
        "I0001": {
            "name": "raw-checker-failed",
            "message": "Oh, look who forgot to use the raw checkers for a built-in module. How typical.",
            "description": "Used to inform that a built-in module has not been checked using the raw checkers."
        },
        "I0010": {
            "name": "bad-inline-option",
            "message": "Oh, how nice! Seems like someone didn't bother with proper formatting for that inline option, or maybe they just don't know it's not allowed in modules. Good job!",
            "description": "Used when an inline option is either badly formatted or can't be used inside modules."
        },
        "I0011": {
            "name": "locally-disabled",
            "message": "Oh, how convenient! Looks like someone decided to disable a message or a messages category using an inline option. How thoughtful of them to make that choice.",
            "description": "Used when an inline option disables a message or a messages category."
        },
        "I0013": {
            "name": "file-ignored",
            "message": "Oh, I'm sorry if it wasn't clear before, but the file won't be checked. But don't worry, I'm sure everything is totally fine with it.",
            "description": "Used to inform that the file will not be checked"
        },
        "I0020": {
            "name": "suppressed-message",
            "message": "Oh, look who's special! There was a little message triggered on a line, but someone oh-so-politely suppressed it with a disable= comment in the file. So important! Just remember, this message isn't even worth generating for messages that are ignored because of some fancy configuration settings.",
            "description": "A message was triggered on a line, but suppressed explicitly by a disable= comment in the file. This message is not generated for messages that are ignored due to configuration settings."
        },
        "I0021": {
            "name": "useless-suppression",
            "message": "It's truly fascinating to see a message being so generously excluded from a line or a block of code, despite never having the delightful opportunity to be called upon. Your diligence in disabling it definitely does not go unnoticed. Quite the opposite, in fact.",
            "description": "Reported when a message is explicitly disabled for a line or a block of code, but never triggered."
        },
        "I0022": {
            "name": "deprecated-pragma",
            "message": "Oh, look at that, some inline pylint options have been renamed or reworked. How exciting! Just a little heads up, you should only use the most recent form. And oh, by the way, just a gentle reminder, NOTE:skip-all is only available with pylint >= 0.26. Just thought you should know, in case you were wondering.",
            "description": "Some inline pylint options have been renamed or reworked, only the most recent form should be used. NOTE:skip-all is only available with pylint >= 0.26"
        },
        "I0023": {
            "name": "use-symbolic-message-instead",
            "message": "Oh, so now we're just randomly enabling or disabling messages by id. Cool, cool.",
            "description": "Used when a message is enabled or disabled by id."
        },
        "I1101": {
            "name": "c-extension-no-member",
            "message": "Oh, look at you, trying to access a non-existent member of a C extension! Too bad we don't have the source to do any static analysis. But hey, no worries! Maybe you can figure it out by snooping around the live objects during runtime. Good luck with that!",
            "description": "Used when a variable is accessed for non-existent member of C extension. Due to unavailability of source static analysis is impossible, but it may be performed by introspecting living objects in run-time."
        }
    }
}